type bit
type bool
type char
type list 'a
type nat
type numeral
type set 'a
type string
type unit
type vector 'b ''a


module Basic_classes = struct
  class Eq
  type Eq_class 'a = {
      val isEqual_method : forall 'a. 
                             (Basic_classes.Eq_class 'a) -> 'a -> 'a -> bool

      val isInequal_method : forall 'a. 
                               (Basic_classes.Eq_class 'a) -> 'a -> 'a -> 
                                                                    bool

  }
  class Ord
  class OrdMaxMin
  type OrdMaxMin_class 'a = {
      val max_method : forall 'a. 
                         (Basic_classes.OrdMaxMin_class 'a) -> 'a -> 'a -> 'a

      val min_method : forall 'a. 
                         (Basic_classes.OrdMaxMin_class 'a) -> 'a -> 'a -> 'a

  }
  type Ord_class 'a = {
      val compare_method : forall 'a. 
                             (Basic_classes.Ord_class 'a) -> 'a -> 'a -> 
                                                                   Basic_classes.ordering

      val isLess_method : forall 'a. 
                            (Basic_classes.Ord_class 'a) -> 'a -> 'a -> bool

      val isLessEqual_method : forall 'a. 
                                 (Basic_classes.Ord_class 'a) -> 'a -> 
                                                                 'a -> 
                                                                 bool

      val isGreater_method : forall 'a. 
                               (Basic_classes.Ord_class 'a) -> 'a -> 
                                                               'a -> 
                                                               bool

      val isGreaterEqual_method : forall 'a. 
                                    (Basic_classes.Ord_class 'a) -> 'a -> 
                                                                    'a -> 
                                                                    bool

  }
  class SetType
  type SetType_class 'a = {
      val setElemCompare_method : forall 'a. 
                                    (Basic_classes.SetType_class 'a) -> 
                                    'a -> 'a -> Basic_classes.ordering

  }
  type ordering

  val < : forall 'a. (Basic_classes.Ord 'a) => 'a -> 'a -> bool
  val <= : forall 'a. (Basic_classes.Ord 'a) => 'a -> 'a -> bool
  val <> : forall 'a. (Basic_classes.Eq 'a) => 'a -> 'a -> bool
  val = : forall 'a. (Basic_classes.Eq 'a) => 'a -> 'a -> bool
  val > : forall 'a. (Basic_classes.Ord 'a) => 'a -> 'a -> bool
  val >= : forall 'a. (Basic_classes.Ord 'a) => 'a -> 'a -> bool
  val EQ : Basic_classes.ordering
  val GT : Basic_classes.ordering
  val LT : Basic_classes.ordering
  val boolCompare : bool -> bool -> Basic_classes.ordering
  val compare : forall 'a. 
                  (Basic_classes.Ord 'a) => 
                    'a -> 'a -> Basic_classes.ordering
  val defaultCompare : forall 'a. 'a -> 'a -> Basic_classes.ordering
  val defaultGreater : forall 'a. 'a -> 'a -> bool
  val defaultGreaterEq : forall 'a. 'a -> 'a -> bool
  val defaultLess : forall 'a. 'a -> 'a -> bool
  val defaultLessEq : forall 'a. 'a -> 'a -> bool
  val defaultMax : forall 'a. (Basic_classes.Ord 'a) => 'a -> 'a -> 'a
  val defaultMin : forall 'a. (Basic_classes.Ord 'a) => 'a -> 'a -> 'a
  val genericCompare : forall 'a. 
                         ('a -> 'a -> bool) -> ('a -> 'a -> bool) -> 
                                               'a -> 'a -> Basic_classes.ordering
  val instance_Basic_classes_Eq_Basic_classes_ordering_dict : 
                                                                Basic_classes.Eq_class 
                                                                Basic_classes.ordering
  val instance_Basic_classes_Eq_bool_dict : Basic_classes.Eq_class bool
  val instance_Basic_classes_Eq_tup2_dict : forall 'a 'b. 
                                              (Basic_classes.Eq 'a)
                                                (Basic_classes.Eq 'b) => 
                                                Basic_classes.Eq_class 
                                                ('a * 'b)
  val instance_Basic_classes_Eq_tup3_dict : forall 'a 'b 'c. 
                                              (Basic_classes.Eq 'a)
                                                (Basic_classes.Eq 'b)
                                                (Basic_classes.Eq 'c) => 
                                                Basic_classes.Eq_class 
                                                ('a * 'b * 'c)
  val instance_Basic_classes_Eq_var_dict : forall 'a. 
                                             Basic_classes.Eq_class 'a
  val instance_Basic_classes_OrdMaxMin_var_dict : forall 'a. 
                                                    (Basic_classes.Ord 'a) => 
                                                      Basic_classes.OrdMaxMin_class 
                                                      'a
  val instance_Basic_classes_Ord_tup2_dict : forall 'a 'b. 
                                               (Basic_classes.Ord 'a)
                                                 (Basic_classes.Ord 'b) => 
                                                 Basic_classes.Ord_class 
                                                 ('a * 'b)
  val instance_Basic_classes_Ord_tup3_dict : forall 'a 'b 'c. 
                                               (Basic_classes.Ord 'a)
                                                 (Basic_classes.Ord 'b)
                                                 (Basic_classes.Ord 'c) => 
                                                 Basic_classes.Ord_class 
                                                 ('a * 'b * 'c)
  val instance_Basic_classes_SetType_bool_dict : 
                                                   Basic_classes.SetType_class 
                                                   bool
  val instance_Basic_classes_SetType_tup2_dict : forall 'a 'b. 
                                                   (Basic_classes.SetType 'a)
                                                     (Basic_classes.SetType
                                                      'b) => 
                                                     Basic_classes.SetType_class 
                                                     ('a * 'b)
  val instance_Basic_classes_SetType_tup3_dict : forall 'a 'b 'c. 
                                                   (Basic_classes.SetType 'a)
                                                     (Basic_classes.SetType
                                                      'b)
                                                     (Basic_classes.SetType
                                                      'c) => 
                                                     Basic_classes.SetType_class 
                                                     ('a * 'b * 'c)
  val instance_Basic_classes_SetType_var_dict : forall 'a. 
                                                  Basic_classes.SetType_class 
                                                  'a
  val isEqual : forall 'a. (Basic_classes.Eq 'a) => 'a -> 'a -> bool
  val isGreater : forall 'a. (Basic_classes.Ord 'a) => 'a -> 'a -> bool
  val isGreaterEqual : forall 'a. (Basic_classes.Ord 'a) => 'a -> 'a -> bool
  val isInequal : forall 'a. (Basic_classes.Eq 'a) => 'a -> 'a -> bool
  val isLess : forall 'a. (Basic_classes.Ord 'a) => 'a -> 'a -> bool
  val isLessEqual : forall 'a. (Basic_classes.Ord 'a) => 'a -> 'a -> bool
  val max : forall 'a. (Basic_classes.OrdMaxMin 'a) => 'a -> 'a -> 'a
  val maxByLessEqual : forall 'a. ('a -> 'a -> bool) -> 'a -> 'a -> 'a
  val min : forall 'a. (Basic_classes.OrdMaxMin 'a) => 'a -> 'a -> 'a
  val minByLessEqual : forall 'a. ('a -> 'a -> bool) -> 'a -> 'a -> 'a
  val ordCompare : forall 'a. 
                     (Basic_classes.Eq 'a) (Basic_classes.Ord 'a) => 
                       'a -> 'a -> Basic_classes.ordering
  val orderingEqual : 
                        Basic_classes.ordering -> Basic_classes.ordering -> 
                                                  bool
  val orderingIsEqual : Basic_classes.ordering -> bool
  val orderingIsGreater : Basic_classes.ordering -> bool
  val orderingIsGreaterEqual : Basic_classes.ordering -> bool
  val orderingIsLess : Basic_classes.ordering -> bool
  val orderingIsLessEqual : Basic_classes.ordering -> bool
  val ordering_cases : forall 'a. 
                         Basic_classes.ordering -> 'a -> 'a -> 'a -> 'a
  val pairCompare : forall 'a 'b. 
                      ('a -> 'a -> Basic_classes.ordering) -> ('b -> 
                                                              'b -> Basic_classes.ordering) -> 
                                                              ('a * 'b) -> 
                                                              ('a * 'b) -> 
                                                              Basic_classes.ordering
  val pairEqual : forall 'a 'b. 
                    (Basic_classes.Eq 'a) (Basic_classes.Eq 'b) => 
                      ('a * 'b) -> ('a * 'b) -> bool
  val pairEqualBy : forall 'a 'b. 
                      ('a -> 'a -> bool) -> ('b -> 'b -> bool) -> ('a * 'b) -> 
                                                                  ('a * 'b) -> 
                                                                  bool
  val pairGreater : forall 'a 'b. 
                      (Basic_classes.Ord 'a) (Basic_classes.Ord 'b) => 
                        ('a * 'b) -> ('a * 'b) -> bool
  val pairGreaterEq : forall 'a 'b. 
                        (Basic_classes.Ord 'a) (Basic_classes.Ord 'b) => 
                          ('a * 'b) -> ('a * 'b) -> bool
  val pairLess : forall 'a 'b. 
                   (Basic_classes.Ord 'a) (Basic_classes.Ord 'b) => 
                     ('b * 'a) -> ('b * 'a) -> bool
  val pairLessEq : forall 'a 'b. 
                     (Basic_classes.Ord 'a) (Basic_classes.Ord 'b) => 
                       ('b * 'a) -> ('b * 'a) -> bool
  val setElemCompare : forall 'a. 
                         (Basic_classes.SetType 'a) => 
                           'a -> 'a -> Basic_classes.ordering
  val tripleCompare : forall 'a 'b 'c. 
                        ('a -> 'a -> Basic_classes.ordering) -> ('b -> 
                                                                'b -> 
                                                                Basic_classes.ordering) -> 
                                                                ('c -> 
                                                                'c -> 
                                                                Basic_classes.ordering) -> 
                                                                ('a * 'b * 'c) -> 
                                                                ('a * 'b * 'c) -> 
                                                                Basic_classes.ordering
  val tripleEqual : forall 'a 'b 'c. 
                      (Basic_classes.Eq 'a) (Basic_classes.Eq 'b)
                        (Basic_classes.Eq 'c) => 
                        ('a * 'b * 'c) -> ('a * 'b * 'c) -> bool
  val tripleGreater : forall 'a 'b 'c. 
                        (Basic_classes.Ord 'a) (Basic_classes.Ord 'b)
                          (Basic_classes.Ord 'c) => 
                          ('c * 'b * 'a) -> ('c * 'b * 'a) -> bool
  val tripleGreaterEq : forall 'a 'b 'c. 
                          (Basic_classes.Ord 'a) (Basic_classes.Ord 'b)
                            (Basic_classes.Ord 'c) => 
                            ('c * 'b * 'a) -> ('c * 'b * 'a) -> bool
  val tripleLess : forall 'a 'b 'c. 
                     (Basic_classes.Ord 'a) (Basic_classes.Ord 'b)
                       (Basic_classes.Ord 'c) => 
                       ('a * 'b * 'c) -> ('a * 'b * 'c) -> bool
  val tripleLessEq : forall 'a 'b 'c. 
                       (Basic_classes.Ord 'a) (Basic_classes.Ord 'b)
                         (Basic_classes.Ord 'c) => 
                         ('a * 'b * 'c) -> ('a * 'b * 'c) -> bool
  val unsafe_structural_equality : forall 'a. 'a -> 'a -> bool
  val unsafe_structural_inequality : forall 'a. 'a -> 'a -> bool

  module Instance_Basic_classes_Eq_Basic_classes_ordering = struct

    val <> : Basic_classes.ordering -> Basic_classes.ordering -> bool
    val = : Basic_classes.ordering -> Basic_classes.ordering -> bool

  end

  module Instance_Basic_classes_Eq_bool = struct

    val <> : bool -> bool -> bool
    val = : bool -> bool -> bool

  end

  module Instance_Basic_classes_Eq_tup2 = struct

    val <> : forall 'a 'b. 
               (Basic_classes.Eq 'a) (Basic_classes.Eq 'b) => 
                 ('a * 'b) -> ('a * 'b) -> bool
    val = : forall 'a 'b. 
              (Basic_classes.Eq 'a) (Basic_classes.Eq 'b) => 
                ('a * 'b) -> ('a * 'b) -> bool

  end

  module Instance_Basic_classes_Eq_tup3 = struct

    val <> : forall 'a 'b 'c. 
               (Basic_classes.Eq 'a) (Basic_classes.Eq 'b)
                 (Basic_classes.Eq 'c) => 
                 ('a * 'b * 'c) -> ('a * 'b * 'c) -> bool
    val = : forall 'a 'b 'c. 
              (Basic_classes.Eq 'a) (Basic_classes.Eq 'b)
                (Basic_classes.Eq 'c) => 
                ('a * 'b * 'c) -> ('a * 'b * 'c) -> bool

  end

  module Instance_Basic_classes_Eq_var = struct

    val <> : forall 'a. 'a -> 'a -> bool
    val = : forall 'a. 'a -> 'a -> bool

  end

  module Instance_Basic_classes_OrdMaxMin_var = struct

    val max : forall 'a. (Basic_classes.Ord 'a) => 'a -> 'a -> 'a
    val min : forall 'a. (Basic_classes.Ord 'a) => 'a -> 'a -> 'a

  end

  module Instance_Basic_classes_Ord_tup2 = struct

    val < : forall 'a 'b. 
              (Basic_classes.Ord 'a) (Basic_classes.Ord 'b) => 
                ('a * 'b) -> ('a * 'b) -> bool
    val <= : forall 'a 'b. 
               (Basic_classes.Ord 'a) (Basic_classes.Ord 'b) => 
                 ('a * 'b) -> ('a * 'b) -> bool
    val > : forall 'a 'b. 
              (Basic_classes.Ord 'a) (Basic_classes.Ord 'b) => 
                ('a * 'b) -> ('a * 'b) -> bool
    val >= : forall 'a 'b. 
               (Basic_classes.Ord 'a) (Basic_classes.Ord 'b) => 
                 ('a * 'b) -> ('a * 'b) -> bool
    val compare : forall 'a 'b. 
                    (Basic_classes.Ord 'a) (Basic_classes.Ord 'b) => 
                      ('a * 'b) -> ('a * 'b) -> Basic_classes.ordering

  end

  module Instance_Basic_classes_Ord_tup3 = struct

    val < : forall 'a 'b 'c. 
              (Basic_classes.Ord 'a) (Basic_classes.Ord 'b)
                (Basic_classes.Ord 'c) => 
                ('a * 'b * 'c) -> ('a * 'b * 'c) -> bool
    val <= : forall 'a 'b 'c. 
               (Basic_classes.Ord 'a) (Basic_classes.Ord 'b)
                 (Basic_classes.Ord 'c) => 
                 ('a * 'b * 'c) -> ('a * 'b * 'c) -> bool
    val > : forall 'a 'b 'c. 
              (Basic_classes.Ord 'a) (Basic_classes.Ord 'b)
                (Basic_classes.Ord 'c) => 
                ('a * 'b * 'c) -> ('a * 'b * 'c) -> bool
    val >= : forall 'a 'b 'c. 
               (Basic_classes.Ord 'a) (Basic_classes.Ord 'b)
                 (Basic_classes.Ord 'c) => 
                 ('a * 'b * 'c) -> ('a * 'b * 'c) -> bool
    val compare : forall 'a 'b 'c. 
                    (Basic_classes.Ord 'a) (Basic_classes.Ord 'b)
                      (Basic_classes.Ord 'c) => 
                      ('a * 'b * 'c) -> ('a * 'b * 'c) -> Basic_classes.ordering

  end

  module Instance_Basic_classes_SetType_bool = struct

    val setElemCompare : bool -> bool -> Basic_classes.ordering

  end

  module Instance_Basic_classes_SetType_tup2 = struct

    val setElemCompare : forall 'a 'b. 
                           (Basic_classes.SetType 'a)
                             (Basic_classes.SetType 'b) => 
                             ('a * 'b) -> ('a * 'b) -> Basic_classes.ordering

  end

  module Instance_Basic_classes_SetType_tup3 = struct

    val setElemCompare : forall 'a 'b 'c. 
                           (Basic_classes.SetType 'a)
                             (Basic_classes.SetType 'b)
                             (Basic_classes.SetType 'c) => 
                             ('a * 'b * 'c) -> ('a * 'b * 'c) -> Basic_classes.ordering

  end

  module Instance_Basic_classes_SetType_var = struct

    val setElemCompare : forall 'a. 'a -> 'a -> Basic_classes.ordering

  end

end

module Bool = struct

  val && : bool -> bool -> bool
  val --> : bool -> bool -> bool
  val <-> : bool -> bool -> bool
  val and : bool -> bool -> bool
  val equiv : bool -> bool -> bool
  val imp : bool -> bool -> bool
  val not : bool -> bool
  val or : bool -> bool -> bool
  val xor : bool -> bool -> bool
  val || : bool -> bool -> bool

end

module Either = struct
  type either 'a 'b

  val Left : forall 'a 'b. 'a -> Either.either 'a 'b
  val Right : forall 'a 'b. 'b -> Either.either 'a 'b
  val either : forall 'a 'b 'c. 
                 ('a -> 'c) -> ('b -> 'c) -> (Either.either 'a 'b) -> 'c
  val eitherEqual : forall 'a 'b. 
                      (Basic_classes.Eq 'a) (Basic_classes.Eq 'b) => 
                        (Either.either 'a 'b) -> (Either.either 'a 'b) -> 
                                                 bool
  val eitherEqualBy : forall 'a 'b. 
                        ('a -> 'a -> bool) -> ('b -> 'b -> bool) -> (Either.either 
                                                                    'a 
                                                                    'b) -> 
                                                                    (Either.either 
                                                                    'a 
                                                                    'b) -> 
                                                                    bool
  val instance_Basic_classes_Eq_Either_either_dict : forall 'a 'b. 
                                                       (Basic_classes.Eq 'a)
                                                         (Basic_classes.Eq 'b) => 
                                                         Basic_classes.Eq_class 
                                                         (Either.either 
                                                         'a 'b)
  val isLeft : forall 'a 'b. (Either.either 'a 'b) -> bool
  val isRight : forall 'a 'b. (Either.either 'a 'b) -> bool
  val lefts : forall 'a 'b. (list (Either.either 'a 'b)) -> list 'a
  val partitionEither : forall 'a 'b. 
                          (list (Either.either 'a 'b)) -> ((list 'a) *
                                                           (list 'b))
  val rights : forall 'a 'b. (list (Either.either 'a 'b)) -> list 'b

  module Instance_Basic_classes_Eq_Either_either = struct

    val <> : forall 'a 'b. 
               (Basic_classes.Eq 'a) (Basic_classes.Eq 'b) => 
                 (Either.either 'a 'b) -> (Either.either 'a 'b) -> bool
    val = : forall 'a 'b. 
              (Basic_classes.Eq 'a) (Basic_classes.Eq 'b) => 
                (Either.either 'a 'b) -> (Either.either 'a 'b) -> bool

  end

end

module Function = struct

  val $ : forall 'a 'b. ('a -> 'b) -> 'a -> 'b
  val apply : forall 'a 'b. ('a -> 'b) -> 'a -> 'b
  val comb : forall 'a 'b 'c. ('b -> 'c) -> ('a -> 'b) -> 'a -> 'c
  val const : forall 'a 'b. 'a -> 'b -> 'a
  val flip : forall 'a 'b 'c. ('a -> 'b -> 'c) -> 'b -> 'a -> 'c
  val id : forall 'a. 'a -> 'a

end

module List = struct

  val ++ : forall 'a. (list 'a) -> (list 'a) -> list 'a
  val :: : forall 'a. 'a -> (list 'a) -> list 'a
  val all : forall 'a. ('a -> bool) -> (list 'a) -> bool
  val any : forall 'a. ('a -> bool) -> (list 'a) -> bool
  val append : forall 'a. (list 'a) -> (list 'a) -> list 'a
  val concat : forall 'a. (list (list 'a)) -> list 'a
  val concatMap : forall 'a 'b. ('a -> list 'b) -> (list 'a) -> list 'b
  val cons : forall 'a. 'a -> (list 'a) -> list 'a
  val delete : forall 'a. (Basic_classes.Eq 'a) => 'a -> (list 'a) -> list 'a
  val deleteBy : forall 'a. ('a -> 'a -> bool) -> 'a -> (list 'a) -> list 'a
  val deleteFirst : forall 'a. 
                      ('a -> bool) -> (list 'a) -> Maybe.maybe (list 'a)
  val dest_init : forall 'a. (list 'a) -> Maybe.maybe ((list 'a) * 'a)
  val dest_init_aux : forall 'a. 
                        (list 'a) -> 'a -> (list 'a) -> ((list 'a) * 'a)
  val drop : forall 'a. nat -> (list 'a) -> list 'a
  val dropWhile : forall 'a. ('a -> bool) -> (list 'a) -> list 'a
  val elem : forall 'a. (Basic_classes.Eq 'a) => 'a -> (list 'a) -> bool
  val elemBy : forall 'a. ('a -> 'a -> bool) -> 'a -> (list 'a) -> bool
  val elemIndex : forall 'a. 
                    (Basic_classes.Eq 'a) => 
                      'a -> (list 'a) -> Maybe.maybe nat
  val elemIndices : forall 'a. 
                      (Basic_classes.Eq 'a) => 'a -> (list 'a) -> list nat
  val filter : forall 'a. ('a -> bool) -> (list 'a) -> list 'a
  val find : forall 'a. ('a -> bool) -> (list 'a) -> Maybe.maybe 'a
  val findIndex : forall 'a. ('a -> bool) -> (list 'a) -> Maybe.maybe nat
  val findIndices : forall 'a. ('a -> bool) -> (list 'a) -> list nat
  val findIndices_aux : forall 'a. 
                          nat -> ('a -> bool) -> (list 'a) -> list nat
  val foldl : forall 'a 'b. ('a -> 'b -> 'a) -> 'a -> (list 'b) -> 'a
  val foldr : forall 'a 'b. ('a -> 'b -> 'b) -> 'b -> (list 'a) -> 'b
  val genlist : forall 'a. (nat -> 'a) -> nat -> list 'a
  val index : forall 'a. (list 'a) -> nat -> Maybe.maybe 'a
  val instance_Basic_classes_Eq_list_dict : forall 'a. 
                                              (Basic_classes.Eq 'a) => 
                                                Basic_classes.Eq_class 
                                                (list 'a)
  val instance_Basic_classes_Ord_list_dict : forall 'a. 
                                               (Basic_classes.Ord 'a) => 
                                                 Basic_classes.Ord_class 
                                                 (list 'a)
  val instance_Basic_classes_SetType_list_dict : forall 'a. 
                                                   (Basic_classes.SetType 'a) => 
                                                     Basic_classes.SetType_class 
                                                     (list 'a)
  val length : forall 'a. (list 'a) -> nat
  val lexicographicCompare : forall 'a. 
                               (Basic_classes.Ord 'a) => 
                                 (list 'a) -> (list 'a) -> Basic_classes.ordering
  val lexicographicCompareBy : forall 'a. 
                                 ('a -> 'a -> Basic_classes.ordering) -> 
                                 (list 'a) -> (list 'a) -> Basic_classes.ordering
  val lexicographicLess : forall 'a. 
                            (Basic_classes.Ord 'a) => 
                              (list 'a) -> (list 'a) -> bool
  val lexicographicLessBy : forall 'a. 
                              ('a -> 'a -> bool) -> ('a -> 'a -> bool) -> 
                                                    (list 'a) -> (list 'a) -> 
                                                                 bool
  val lexicographicLessEq : forall 'a. 
                              (Basic_classes.Ord 'a) => 
                                (list 'a) -> (list 'a) -> bool
  val lexicographicLessEqBy : forall 'a. 
                                ('a -> 'a -> bool) -> ('a -> 'a -> bool) -> 
                                                      (list 'a) -> (list 'a) -> 
                                                                   bool
  val listEqual : forall 'a. 
                    (Basic_classes.Eq 'a) => (list 'a) -> (list 'a) -> bool
  val listEqualBy : forall 'a. 
                      ('a -> 'a -> bool) -> (list 'a) -> (list 'a) -> bool
  val lookup : forall 'a 'b. 
                 (Basic_classes.Eq 'a) => 
                   'a -> (list ('a * 'b)) -> Maybe.maybe 'b
  val lookupBy : forall 'a 'b. 
                   ('a -> 'a -> bool) -> 'a -> (list ('a * 'b)) -> Maybe.maybe 
                                                                   'b
  val map : forall 'a 'b. ('a -> 'b) -> (list 'a) -> list 'b
  val null : forall 'a. (list 'a) -> bool
  val partition : forall 'a. 
                    ('a -> bool) -> (list 'a) -> ((list 'a) * (list 'a))
  val replicate : forall 'a. nat -> 'a -> list 'a
  val reverse : forall 'a. (list 'a) -> list 'a
  val reverseAppend : forall 'a. (list 'a) -> (list 'a) -> list 'a
  val reverseMap : forall 'a 'b. ('a -> 'b) -> (list 'a) -> list 'b
  val reversePartition : forall 'a. 
                           ('a -> bool) -> (list 'a) -> ((list 'a) *
                                                         (list 'a))
  val snoc : forall 'a. 'a -> (list 'a) -> list 'a
  val splitAt : forall 'a. nat -> (list 'a) -> ((list 'a) * (list 'a))
  val take : forall 'a. nat -> (list 'a) -> list 'a
  val takeWhile : forall 'a. ('a -> bool) -> (list 'a) -> list 'a
  val unzip : forall 'a 'b. (list ('a * 'b)) -> ((list 'a) * (list 'b))
  val update : forall 'a. (list 'a) -> nat -> 'a -> list 'a
  val zip : forall 'a 'b. (list 'a) -> (list 'b) -> list ('a * 'b)

  module Instance_Basic_classes_Eq_list = struct

    val <> : forall 'a. 
               (Basic_classes.Eq 'a) => (list 'a) -> (list 'a) -> bool
    val = : forall 'a. 
              (Basic_classes.Eq 'a) => (list 'a) -> (list 'a) -> bool

  end

  module Instance_Basic_classes_Ord_list = struct

    val < : forall 'a. 
              (Basic_classes.Ord 'a) => (list 'a) -> (list 'a) -> bool
    val <= : forall 'a. 
               (Basic_classes.Ord 'a) => (list 'a) -> (list 'a) -> bool
    val > : forall 'a. 
              (Basic_classes.Ord 'a) => (list 'a) -> (list 'a) -> bool
    val >= : forall 'a. 
               (Basic_classes.Ord 'a) => (list 'a) -> (list 'a) -> bool
    val compare : forall 'a. 
                    (Basic_classes.Ord 'a) => 
                      (list 'a) -> (list 'a) -> Basic_classes.ordering

  end

  module Instance_Basic_classes_SetType_list = struct

    val setElemCompare : forall 'a. 
                           (Basic_classes.SetType 'a) => 
                             (list 'a) -> (list 'a) -> Basic_classes.ordering

  end

end

module Map = struct
  class MapKeyType
  type MapKeyType_class 'a = {
      val mapKeyCompare_method : forall 'a. 
                                   (Map.MapKeyType_class 'a) -> 'a -> 
                                                                'a -> 
                                                                Basic_classes.ordering

  }
  type map 'k 'v

  val all : forall 'k 'v. 
              (Map.MapKeyType 'k) (Basic_classes.Eq 'v) => 
                ('k -> 'v -> bool) -> (Map.map 'k 'v) -> bool
  val any : forall 'k 'v. 
              (Map.MapKeyType 'k) (Basic_classes.Eq 'v) => 
                ('k -> 'v -> bool) -> (Map.map 'k 'v) -> bool
  val delete : forall 'k 'v. 
                 (Map.MapKeyType 'k) => 
                   'k -> (Map.map 'k 'v) -> Map.map 'k 'v
  val deleteBy : forall 'k 'v. 
                   ('k -> 'k -> Basic_classes.ordering) -> 'k -> (Map.map 
                                                                 'k 'v) -> 
                                                                 Map.map 
                                                                 'k 'v
  val deleteSwap : forall 'k 'v. 
                     (Map.MapKeyType 'k) => 
                       (Map.map 'k 'v) -> 'k -> Map.map 'k 'v
  val domain : forall 'k 'v. 
                 (Map.MapKeyType 'k) (Basic_classes.SetType 'k) => 
                   (Map.map 'k 'v) -> set 'k
  val domainBy : forall 'k 'v. 
                   ('k -> 'k -> Basic_classes.ordering) -> (Map.map 'k 'v) -> 
                                                           set 'k
  val empty : forall 'k 'v. (Map.MapKeyType 'k) => Map.map 'k 'v
  val emptyBy : forall 'k 'v. 
                  ('k -> 'k -> Basic_classes.ordering) -> Map.map 'k 'v
  val findWithDefault : forall 'k 'v. 
                          (Map.MapKeyType 'k) => 
                            'k -> 'v -> (Map.map 'k 'v) -> 'v
  val fromList : forall 'k 'v. 
                   (Map.MapKeyType 'k) => (list ('k * 'v)) -> Map.map 'k 'v
  val insert : forall 'k 'v. 
                 (Map.MapKeyType 'k) => 
                   'k -> 'v -> (Map.map 'k 'v) -> Map.map 'k 'v
  val instance_Basic_classes_Eq_Map_map_dict : forall 'k 'v. 
                                                 (Basic_classes.Eq 'k)
                                                   (Basic_classes.Eq 'v) => 
                                                   Basic_classes.Eq_class 
                                                   (Map.map 'k 'v)
  val instance_Map_MapKeyType_var_dict : forall 'a. 
                                           (Basic_classes.SetType 'a) => 
                                             Map.MapKeyType_class 'a
  val lookup : forall 'k 'v. 
                 (Map.MapKeyType 'k) => 
                   'k -> (Map.map 'k 'v) -> Maybe.maybe 'v
  val lookupBy : forall 'k 'v. 
                   ('k -> 'k -> Basic_classes.ordering) -> 'k -> (Map.map 
                                                                 'k 'v) -> 
                                                                 Maybe.maybe 
                                                                 'v
  val map : forall 'k 'v 'w. 
              (Map.MapKeyType 'k) => 
                ('v -> 'w) -> (Map.map 'k 'v) -> Map.map 'k 'w
  val mapEqual : forall 'k 'v. 
                   (Basic_classes.Eq 'k) (Basic_classes.Eq 'v) => 
                     (Map.map 'k 'v) -> (Map.map 'k 'v) -> bool
  val mapEqualBy : forall 'k 'v. 
                     ('k -> 'k -> bool) -> ('v -> 'v -> bool) -> (Map.map 
                                                                 'k 'v) -> 
                                                                 (Map.map 
                                                                 'k 'v) -> 
                                                                 bool
  val mapKeyCompare : forall 'a. 
                        (Map.MapKeyType 'a) => 
                          'a -> 'a -> Basic_classes.ordering
  val member : forall 'k 'v. 
                 (Map.MapKeyType 'k) (Basic_classes.SetType 'k)
                   (Basic_classes.Eq 'k) => 'k -> (Map.map 'k 'v) -> bool
  val notMember : forall 'k 'v. 
                    (Map.MapKeyType 'k) (Basic_classes.SetType 'k)
                      (Basic_classes.Eq 'k) => 'k -> (Map.map 'k 'v) -> bool
  val null : forall 'k 'v. 
               (Map.MapKeyType 'k) (Basic_classes.Eq 'k)
                 (Basic_classes.Eq 'v) => (Map.map 'k 'v) -> bool
  val range : forall 'k 'v. 
                (Map.MapKeyType 'k) (Basic_classes.SetType 'v) => 
                  (Map.map 'k 'v) -> set 'v
  val rangeBy : forall 'k 'v. 
                  ('v -> 'v -> Basic_classes.ordering) -> (Map.map 'k 'v) -> 
                                                          set 'v
  val singleton : forall 'k 'v. 
                    (Map.MapKeyType 'k) => 'k -> 'v -> Map.map 'k 'v
  val size : forall 'k 'v. 
               (Map.MapKeyType 'k) (Basic_classes.SetType 'k) => 
                 (Map.map 'k 'v) -> nat
  val toSet : forall 'k 'v. 
                (Map.MapKeyType 'k) (Basic_classes.SetType 'k)
                  (Basic_classes.SetType 'v) => 
                  (Map.map 'k 'v) -> set ('k * 'v)
  val toSetBy : forall 'k 'v. 
                  (('k * 'v) -> ('k * 'v) -> Basic_classes.ordering) -> 
                  (Map.map 'k 'v) -> set ('k * 'v)
  val union : forall 'k 'v. 
                (Map.MapKeyType 'k) => 
                  (Map.map 'k 'v) -> (Map.map 'k 'v) -> Map.map 'k 'v
  val unions : forall 'k 'v. 
                 (Map.MapKeyType 'k) => 
                   (list (Map.map 'k 'v)) -> Map.map 'k 'v

  module Instance_Basic_classes_Eq_Map_map = struct

    val <> : forall 'k 'v. 
               (Basic_classes.Eq 'k) (Basic_classes.Eq 'v) => 
                 (Map.map 'k 'v) -> (Map.map 'k 'v) -> bool
    val = : forall 'k 'v. 
              (Basic_classes.Eq 'k) (Basic_classes.Eq 'v) => 
                (Map.map 'k 'v) -> (Map.map 'k 'v) -> bool

  end

  module Instance_Map_MapKeyType_var = struct

    val mapKeyCompare : forall 'a. 
                          (Basic_classes.SetType 'a) => 
                            'a -> 'a -> Basic_classes.ordering

  end

end

module Maybe = struct
  type maybe 'a

  val Just : forall 'a. 'a -> Maybe.maybe 'a
  val Nothing : forall 'a. Maybe.maybe 'a
  val bind : forall 'a 'b. 
               (Maybe.maybe 'a) -> ('a -> Maybe.maybe 'b) -> Maybe.maybe 'b
  val fromMaybe : forall 'a. 'a -> (Maybe.maybe 'a) -> 'a
  val instance_Basic_classes_Eq_Maybe_maybe_dict : forall 'a. 
                                                     (Basic_classes.Eq 'a) => 
                                                       Basic_classes.Eq_class 
                                                       (Maybe.maybe 'a)
  val instance_Basic_classes_SetType_Maybe_maybe_dict : forall 'a. 
                                                          (Basic_classes.SetType
                                                           'a) => 
                                                            Basic_classes.SetType_class 
                                                            (Maybe.maybe 'a)
  val isJust : forall 'a. (Maybe.maybe 'a) -> bool
  val isNothing : forall 'a. (Maybe.maybe 'a) -> bool
  val map : forall 'a 'b. ('a -> 'b) -> (Maybe.maybe 'a) -> Maybe.maybe 'b
  val maybe : forall 'a 'b. 'b -> ('a -> 'b) -> (Maybe.maybe 'a) -> 'b
  val maybeCompare : forall 'a 'b. 
                       ('b -> 'a -> Basic_classes.ordering) -> (Maybe.maybe 
                                                               'b) -> 
                                                               (Maybe.maybe 
                                                               'a) -> 
                                                               Basic_classes.ordering
  val maybeEqual : forall 'a. 
                     (Basic_classes.Eq 'a) => 
                       (Maybe.maybe 'a) -> (Maybe.maybe 'a) -> bool
  val maybeEqualBy : forall 'a. 
                       ('a -> 'a -> bool) -> (Maybe.maybe 'a) -> (Maybe.maybe 
                                                                 'a) -> 
                                                                 bool

  module Instance_Basic_classes_Eq_Maybe_maybe = struct

    val <> : forall 'a. 
               (Basic_classes.Eq 'a) => 
                 (Maybe.maybe 'a) -> (Maybe.maybe 'a) -> bool
    val = : forall 'a. 
              (Basic_classes.Eq 'a) => 
                (Maybe.maybe 'a) -> (Maybe.maybe 'a) -> bool

  end

  module Instance_Basic_classes_SetType_Maybe_maybe = struct

    val setElemCompare : forall 'a. 
                           (Basic_classes.SetType 'a) => 
                             (Maybe.maybe 'a) -> (Maybe.maybe 'a) -> 
                                                 Basic_classes.ordering

  end

end

module Num = struct
  class NumAbs
  type NumAbs_class 'a = {
      val abs_method : forall 'a. (Num.NumAbs_class 'a) -> 'a -> 'a

  }
  class NumAdd
  type NumAdd_class 'a = {
      val numAdd_method : forall 'a. (Num.NumAdd_class 'a) -> 'a -> 'a -> 'a

  }
  class NumDivision
  type NumDivision_class 'a = {
      val numDivision_method : forall 'a. 
                                 (Num.NumDivision_class 'a) -> 'a -> 'a -> 'a

  }
  class NumIntegerDivision
  type NumIntegerDivision_class 'a = {
      val div_method : forall 'a. 
                         (Num.NumIntegerDivision_class 'a) -> 'a -> 'a -> 'a

  }
  class NumMinus
  type NumMinus_class 'a = {
      val numMinus_method : forall 'a. 
                              (Num.NumMinus_class 'a) -> 'a -> 'a -> 'a

  }
  class NumMult
  type NumMult_class 'a = {
      val numMult_method : forall 'a. 
                             (Num.NumMult_class 'a) -> 'a -> 'a -> 'a

  }
  class NumNegate
  type NumNegate_class 'a = {
      val numNegate_method : forall 'a. (Num.NumNegate_class 'a) -> 'a -> 'a

  }
  class NumPow
  type NumPow_class 'a = {
      val numPow_method : forall 'a. (Num.NumPow_class 'a) -> 'a -> nat -> 'a

  }
  class NumPred
  type NumPred_class 'a = {
      val pred_method : forall 'a. (Num.NumPred_class 'a) -> 'a -> 'a

  }
  class NumRemainder
  type NumRemainder_class 'a = {
      val mod_method : forall 'a. 
                         (Num.NumRemainder_class 'a) -> 'a -> 'a -> 'a

  }
  class NumSucc
  type NumSucc_class 'a = {
      val succ_method : forall 'a. (Num.NumSucc_class 'a) -> 'a -> 'a

  }
  class Numeral
  type Numeral_class 'a = {
      val fromNumeral_method : forall 'a. 
                                 (Num.Numeral_class 'a) -> numeral -> 'a

  }
  type float32
  type float64
  type int
  type int32
  type int64
  type integer
  type natural
  type rational

  val * : forall 'a. (Num.NumMult 'a) => 'a -> 'a -> 'a
  val ** : forall 'a. (Num.NumPow 'a) => 'a -> nat -> 'a
  val + : forall 'a. (Num.NumAdd 'a) => 'a -> 'a -> 'a
  val - : forall 'a. (Num.NumMinus 'a) => 'a -> 'a -> 'a
  val / : forall 'a. (Num.NumDivision 'a) => 'a -> 'a -> 'a
  val abs : forall 'a. (Num.NumAbs 'a) => 'a -> 'a
  val div : forall 'a. (Num.NumIntegerDivision 'a) => 'a -> 'a -> 'a
  val fromNumeral : forall 'a. (Num.Numeral 'a) => numeral -> 'a
  val gen_pow : forall 'a. 'a -> ('a -> 'a -> 'a) -> 'a -> nat -> 'a
  val gen_pow_aux : forall 'a. ('a -> 'a -> 'a) -> 'a -> 'a -> nat -> 'a
  val instance_Basic_classes_Eq_Num_int32_dict : 
                                                   Basic_classes.Eq_class 
                                                   Num.int32
  val instance_Basic_classes_Eq_Num_int64_dict : 
                                                   Basic_classes.Eq_class 
                                                   Num.int64
  val instance_Basic_classes_Eq_Num_int_dict : Basic_classes.Eq_class Num.int
  val instance_Basic_classes_Eq_Num_integer_dict : 
                                                     Basic_classes.Eq_class 
                                                     Num.integer
  val instance_Basic_classes_Eq_Num_natural_dict : 
                                                     Basic_classes.Eq_class 
                                                     Num.natural
  val instance_Basic_classes_Eq_nat_dict : Basic_classes.Eq_class nat
  val instance_Basic_classes_OrdMaxMin_Num_int32_dict : 
                                                          Basic_classes.OrdMaxMin_class 
                                                          Num.int32
  val instance_Basic_classes_OrdMaxMin_Num_int64_dict : 
                                                          Basic_classes.OrdMaxMin_class 
                                                          Num.int64
  val instance_Basic_classes_OrdMaxMin_Num_int_dict : 
                                                        Basic_classes.OrdMaxMin_class 
                                                        Num.int
  val instance_Basic_classes_OrdMaxMin_Num_integer_dict : 
                                                            Basic_classes.OrdMaxMin_class 
                                                            Num.integer
  val instance_Basic_classes_OrdMaxMin_Num_natural_dict : 
                                                            Basic_classes.OrdMaxMin_class 
                                                            Num.natural
  val instance_Basic_classes_OrdMaxMin_nat_dict : 
                                                    Basic_classes.OrdMaxMin_class 
                                                    nat
  val instance_Basic_classes_Ord_Num_int32_dict : 
                                                    Basic_classes.Ord_class 
                                                    Num.int32
  val instance_Basic_classes_Ord_Num_int64_dict : 
                                                    Basic_classes.Ord_class 
                                                    Num.int64
  val instance_Basic_classes_Ord_Num_int_dict : 
                                                  Basic_classes.Ord_class 
                                                  Num.int
  val instance_Basic_classes_Ord_Num_integer_dict : 
                                                      Basic_classes.Ord_class 
                                                      Num.integer
  val instance_Basic_classes_Ord_Num_natural_dict : 
                                                      Basic_classes.Ord_class 
                                                      Num.natural
  val instance_Basic_classes_Ord_nat_dict : Basic_classes.Ord_class nat
  val instance_Basic_classes_SetType_Num_int32_dict : 
                                                        Basic_classes.SetType_class 
                                                        Num.int32
  val instance_Basic_classes_SetType_Num_int64_dict : 
                                                        Basic_classes.SetType_class 
                                                        Num.int64
  val instance_Basic_classes_SetType_Num_int_dict : 
                                                      Basic_classes.SetType_class 
                                                      Num.int
  val instance_Basic_classes_SetType_Num_integer_dict : 
                                                          Basic_classes.SetType_class 
                                                          Num.integer
  val instance_Basic_classes_SetType_Num_natural_dict : 
                                                          Basic_classes.SetType_class 
                                                          Num.natural
  val instance_Basic_classes_SetType_nat_dict : 
                                                  Basic_classes.SetType_class 
                                                  nat
  val instance_Num_NumAbs_Num_int32_dict : Num.NumAbs_class Num.int32
  val instance_Num_NumAbs_Num_int64_dict : Num.NumAbs_class Num.int64
  val instance_Num_NumAbs_Num_int_dict : Num.NumAbs_class Num.int
  val instance_Num_NumAbs_Num_integer_dict : Num.NumAbs_class Num.integer
  val instance_Num_NumAdd_Num_int32_dict : Num.NumAdd_class Num.int32
  val instance_Num_NumAdd_Num_int64_dict : Num.NumAdd_class Num.int64
  val instance_Num_NumAdd_Num_int_dict : Num.NumAdd_class Num.int
  val instance_Num_NumAdd_Num_integer_dict : Num.NumAdd_class Num.integer
  val instance_Num_NumAdd_Num_natural_dict : Num.NumAdd_class Num.natural
  val instance_Num_NumAdd_nat_dict : Num.NumAdd_class nat
  val instance_Num_NumDivision_Num_int32_dict : 
                                                  Num.NumDivision_class 
                                                  Num.int32
  val instance_Num_NumDivision_Num_int64_dict : 
                                                  Num.NumDivision_class 
                                                  Num.int64
  val instance_Num_NumDivision_Num_int_dict : Num.NumDivision_class Num.int
  val instance_Num_NumDivision_Num_integer_dict : 
                                                    Num.NumDivision_class 
                                                    Num.integer
  val instance_Num_NumDivision_Num_natural_dict : 
                                                    Num.NumDivision_class 
                                                    Num.natural
  val instance_Num_NumDivision_nat_dict : Num.NumDivision_class nat
  val instance_Num_NumIntegerDivision_Num_int32_dict : 
                                                         Num.NumIntegerDivision_class 
                                                         Num.int32
  val instance_Num_NumIntegerDivision_Num_int64_dict : 
                                                         Num.NumIntegerDivision_class 
                                                         Num.int64
  val instance_Num_NumIntegerDivision_Num_int_dict : 
                                                       Num.NumIntegerDivision_class 
                                                       Num.int
  val instance_Num_NumIntegerDivision_Num_integer_dict : 
                                                           Num.NumIntegerDivision_class 
                                                           Num.integer
  val instance_Num_NumIntegerDivision_Num_natural_dict : 
                                                           Num.NumIntegerDivision_class 
                                                           Num.natural
  val instance_Num_NumIntegerDivision_nat_dict : 
                                                   Num.NumIntegerDivision_class 
                                                   nat
  val instance_Num_NumMinus_Num_int32_dict : Num.NumMinus_class Num.int32
  val instance_Num_NumMinus_Num_int64_dict : Num.NumMinus_class Num.int64
  val instance_Num_NumMinus_Num_int_dict : Num.NumMinus_class Num.int
  val instance_Num_NumMinus_Num_integer_dict : Num.NumMinus_class Num.integer
  val instance_Num_NumMinus_Num_natural_dict : Num.NumMinus_class Num.natural
  val instance_Num_NumMinus_nat_dict : Num.NumMinus_class nat
  val instance_Num_NumMult_Num_int32_dict : Num.NumMult_class Num.int32
  val instance_Num_NumMult_Num_int64_dict : Num.NumMult_class Num.int64
  val instance_Num_NumMult_Num_int_dict : Num.NumMult_class Num.int
  val instance_Num_NumMult_Num_integer_dict : Num.NumMult_class Num.integer
  val instance_Num_NumMult_Num_natural_dict : Num.NumMult_class Num.natural
  val instance_Num_NumMult_nat_dict : Num.NumMult_class nat
  val instance_Num_NumNegate_Num_int32_dict : Num.NumNegate_class Num.int32
  val instance_Num_NumNegate_Num_int64_dict : Num.NumNegate_class Num.int64
  val instance_Num_NumNegate_Num_int_dict : Num.NumNegate_class Num.int
  val instance_Num_NumNegate_Num_integer_dict : 
                                                  Num.NumNegate_class 
                                                  Num.integer
  val instance_Num_NumPow_Num_int32_dict : Num.NumPow_class Num.int32
  val instance_Num_NumPow_Num_int64_dict : Num.NumPow_class Num.int64
  val instance_Num_NumPow_Num_int_dict : Num.NumPow_class Num.int
  val instance_Num_NumPow_Num_integer_dict : Num.NumPow_class Num.integer
  val instance_Num_NumPow_Num_natural_dict : Num.NumPow_class Num.natural
  val instance_Num_NumPow_nat_dict : Num.NumPow_class nat
  val instance_Num_NumPred_Num_int32_dict : Num.NumPred_class Num.int32
  val instance_Num_NumPred_Num_int64_dict : Num.NumPred_class Num.int64
  val instance_Num_NumPred_Num_int_dict : Num.NumPred_class Num.int
  val instance_Num_NumPred_Num_integer_dict : Num.NumPred_class Num.integer
  val instance_Num_NumPred_Num_natural_dict : Num.NumPred_class Num.natural
  val instance_Num_NumPred_nat_dict : Num.NumPred_class nat
  val instance_Num_NumRemainder_Num_int32_dict : 
                                                   Num.NumRemainder_class 
                                                   Num.int32
  val instance_Num_NumRemainder_Num_int64_dict : 
                                                   Num.NumRemainder_class 
                                                   Num.int64
  val instance_Num_NumRemainder_Num_int_dict : Num.NumRemainder_class Num.int
  val instance_Num_NumRemainder_Num_integer_dict : 
                                                     Num.NumRemainder_class 
                                                     Num.integer
  val instance_Num_NumRemainder_Num_natural_dict : 
                                                     Num.NumRemainder_class 
                                                     Num.natural
  val instance_Num_NumRemainder_nat_dict : Num.NumRemainder_class nat
  val instance_Num_NumSucc_Num_int32_dict : Num.NumSucc_class Num.int32
  val instance_Num_NumSucc_Num_int64_dict : Num.NumSucc_class Num.int64
  val instance_Num_NumSucc_Num_int_dict : Num.NumSucc_class Num.int
  val instance_Num_NumSucc_Num_integer_dict : Num.NumSucc_class Num.integer
  val instance_Num_NumSucc_Num_natural_dict : Num.NumSucc_class Num.natural
  val instance_Num_NumSucc_nat_dict : Num.NumSucc_class nat
  val instance_Num_Numeral_Num_int32_dict : Num.Numeral_class Num.int32
  val instance_Num_Numeral_Num_int64_dict : Num.Numeral_class Num.int64
  val instance_Num_Numeral_Num_int_dict : Num.Numeral_class Num.int
  val instance_Num_Numeral_Num_integer_dict : Num.Numeral_class Num.integer
  val instance_Num_Numeral_Num_natural_dict : Num.Numeral_class Num.natural
  val instance_Num_Numeral_nat_dict : Num.Numeral_class nat
  val int32Abs : Num.int32 -> Num.int32
  val int32Add : Num.int32 -> Num.int32 -> Num.int32
  val int32Compare : Num.int32 -> Num.int32 -> Basic_classes.ordering
  val int32Div : Num.int32 -> Num.int32 -> Num.int32
  val int32Eq : Num.int32 -> Num.int32 -> bool
  val int32FromInt : Num.int -> Num.int32
  val int32FromInt64 : Num.int64 -> Num.int32
  val int32FromInteger : Num.integer -> Num.int32
  val int32FromNat : nat -> Num.int32
  val int32FromNatural : Num.natural -> Num.int32
  val int32FromNumeral : numeral -> Num.int32
  val int32Greater : Num.int32 -> Num.int32 -> bool
  val int32GreaterEqual : Num.int32 -> Num.int32 -> bool
  val int32Less : Num.int32 -> Num.int32 -> bool
  val int32LessEqual : Num.int32 -> Num.int32 -> bool
  val int32Max : Num.int32 -> Num.int32 -> Num.int32
  val int32Min : Num.int32 -> Num.int32 -> Num.int32
  val int32Minus : Num.int32 -> Num.int32 -> Num.int32
  val int32Mod : Num.int32 -> Num.int32 -> Num.int32
  val int32Mult : Num.int32 -> Num.int32 -> Num.int32
  val int32Negate : Num.int32 -> Num.int32
  val int32Pow : Num.int32 -> nat -> Num.int32
  val int32Pred : Num.int32 -> Num.int32
  val int32Succ : Num.int32 -> Num.int32
  val int64Abs : Num.int64 -> Num.int64
  val int64Add : Num.int64 -> Num.int64 -> Num.int64
  val int64Compare : Num.int64 -> Num.int64 -> Basic_classes.ordering
  val int64Div : Num.int64 -> Num.int64 -> Num.int64
  val int64Eq : Num.int64 -> Num.int64 -> bool
  val int64FromInt : Num.int -> Num.int64
  val int64FromInt32 : Num.int32 -> Num.int64
  val int64FromInteger : Num.integer -> Num.int64
  val int64FromNat : nat -> Num.int64
  val int64FromNatural : Num.natural -> Num.int64
  val int64FromNumeral : numeral -> Num.int64
  val int64Greater : Num.int64 -> Num.int64 -> bool
  val int64GreaterEqual : Num.int64 -> Num.int64 -> bool
  val int64Less : Num.int64 -> Num.int64 -> bool
  val int64LessEqual : Num.int64 -> Num.int64 -> bool
  val int64Max : Num.int64 -> Num.int64 -> Num.int64
  val int64Min : Num.int64 -> Num.int64 -> Num.int64
  val int64Minus : Num.int64 -> Num.int64 -> Num.int64
  val int64Mod : Num.int64 -> Num.int64 -> Num.int64
  val int64Mult : Num.int64 -> Num.int64 -> Num.int64
  val int64Negate : Num.int64 -> Num.int64
  val int64Pow : Num.int64 -> nat -> Num.int64
  val int64Pred : Num.int64 -> Num.int64
  val int64Succ : Num.int64 -> Num.int64
  val intAbs : Num.int -> Num.int
  val intAdd : Num.int -> Num.int -> Num.int
  val intCompare : Num.int -> Num.int -> Basic_classes.ordering
  val intDiv : Num.int -> Num.int -> Num.int
  val intEq : Num.int -> Num.int -> bool
  val intFromInt32 : Num.int32 -> Num.int
  val intFromInt64 : Num.int64 -> Num.int
  val intFromInteger : Num.integer -> Num.int
  val intFromNat : nat -> Num.int
  val intFromNatural : Num.natural -> Num.int
  val intFromNumeral : numeral -> Num.int
  val intGreater : Num.int -> Num.int -> bool
  val intGreaterEqual : Num.int -> Num.int -> bool
  val intLess : Num.int -> Num.int -> bool
  val intLessEqual : Num.int -> Num.int -> bool
  val intMax : Num.int -> Num.int -> Num.int
  val intMin : Num.int -> Num.int -> Num.int
  val intMinus : Num.int -> Num.int -> Num.int
  val intMod : Num.int -> Num.int -> Num.int
  val intMult : Num.int -> Num.int -> Num.int
  val intNegate : Num.int -> Num.int
  val intPow : Num.int -> nat -> Num.int
  val intPred : Num.int -> Num.int
  val intSucc : Num.int -> Num.int
  val integerAbs : Num.integer -> Num.integer
  val integerAdd : Num.integer -> Num.integer -> Num.integer
  val integerCompare : Num.integer -> Num.integer -> Basic_classes.ordering
  val integerDiv : Num.integer -> Num.integer -> Num.integer
  val integerEq : Num.integer -> Num.integer -> bool
  val integerFromInt : Num.int -> Num.integer
  val integerFromInt32 : Num.int32 -> Num.integer
  val integerFromInt64 : Num.int64 -> Num.integer
  val integerFromNat : nat -> Num.integer
  val integerFromNatural : Num.natural -> Num.integer
  val integerFromNumeral : numeral -> Num.integer
  val integerGreater : Num.integer -> Num.integer -> bool
  val integerGreaterEqual : Num.integer -> Num.integer -> bool
  val integerLess : Num.integer -> Num.integer -> bool
  val integerLessEqual : Num.integer -> Num.integer -> bool
  val integerMax : Num.integer -> Num.integer -> Num.integer
  val integerMin : Num.integer -> Num.integer -> Num.integer
  val integerMinus : Num.integer -> Num.integer -> Num.integer
  val integerMod : Num.integer -> Num.integer -> Num.integer
  val integerMult : Num.integer -> Num.integer -> Num.integer
  val integerNegate : Num.integer -> Num.integer
  val integerPow : Num.integer -> nat -> Num.integer
  val integerPred : Num.integer -> Num.integer
  val integerSucc : Num.integer -> Num.integer
  val mod : forall 'a. (Num.NumRemainder 'a) => 'a -> 'a -> 'a
  val natAdd : nat -> nat -> nat
  val natCompare : nat -> nat -> Basic_classes.ordering
  val natDiv : nat -> nat -> nat
  val natEq : nat -> nat -> bool
  val natFromInt : Num.int -> nat
  val natFromInt32 : Num.int32 -> nat
  val natFromInt64 : Num.int64 -> nat
  val natFromInteger : Num.integer -> nat
  val natFromNatural : Num.natural -> nat
  val natFromNumeral : numeral -> nat
  val natGreater : nat -> nat -> bool
  val natGreaterEqual : nat -> nat -> bool
  val natLess : nat -> nat -> bool
  val natLessEqual : nat -> nat -> bool
  val natMax : nat -> nat -> nat
  val natMin : nat -> nat -> nat
  val natMinus : nat -> nat -> nat
  val natMod : nat -> nat -> nat
  val natMult : nat -> nat -> nat
  val natPow : nat -> nat -> nat
  val natPred : nat -> nat
  val natSucc : nat -> nat
  val naturalAdd : Num.natural -> Num.natural -> Num.natural
  val naturalCompare : Num.natural -> Num.natural -> Basic_classes.ordering
  val naturalDiv : Num.natural -> Num.natural -> Num.natural
  val naturalEq : Num.natural -> Num.natural -> bool
  val naturalFromInt : Num.int -> Num.natural
  val naturalFromInt32 : Num.int32 -> Num.natural
  val naturalFromInt64 : Num.int64 -> Num.natural
  val naturalFromInteger : Num.integer -> Num.natural
  val naturalFromNat : nat -> Num.natural
  val naturalFromNumeral : numeral -> Num.natural
  val naturalGreater : Num.natural -> Num.natural -> bool
  val naturalGreaterEqual : Num.natural -> Num.natural -> bool
  val naturalLess : Num.natural -> Num.natural -> bool
  val naturalLessEqual : Num.natural -> Num.natural -> bool
  val naturalMax : Num.natural -> Num.natural -> Num.natural
  val naturalMin : Num.natural -> Num.natural -> Num.natural
  val naturalMinus : Num.natural -> Num.natural -> Num.natural
  val naturalMod : Num.natural -> Num.natural -> Num.natural
  val naturalMult : Num.natural -> Num.natural -> Num.natural
  val naturalPow : Num.natural -> nat -> Num.natural
  val naturalPred : Num.natural -> Num.natural
  val naturalSucc : Num.natural -> Num.natural
  val numAdd : forall 'a. (Num.NumAdd 'a) => 'a -> 'a -> 'a
  val numDivision : forall 'a. (Num.NumDivision 'a) => 'a -> 'a -> 'a
  val numIntegerDivision : forall 'a. 
                             (Num.NumIntegerDivision 'a) => 'a -> 'a -> 'a
  val numMinus : forall 'a. (Num.NumMinus 'a) => 'a -> 'a -> 'a
  val numMult : forall 'a. (Num.NumMult 'a) => 'a -> 'a -> 'a
  val numNegate : forall 'a. (Num.NumNegate 'a) => 'a -> 'a
  val numPow : forall 'a. (Num.NumPow 'a) => 'a -> nat -> 'a
  val numRemainder : forall 'a. (Num.NumRemainder 'a) => 'a -> 'a -> 'a
  val pred : forall 'a. (Num.NumPred 'a) => 'a -> 'a
  val string_of_natural : Num.natural -> string
  val succ : forall 'a. (Num.NumSucc 'a) => 'a -> 'a
  val ~ : forall 'a. (Num.NumNegate 'a) => 'a -> 'a

  module Instance_Basic_classes_Eq_Num_int = struct

    val <> : Num.int -> Num.int -> bool
    val = : Num.int -> Num.int -> bool

  end

  module Instance_Basic_classes_Eq_Num_int32 = struct

    val <> : Num.int32 -> Num.int32 -> bool
    val = : Num.int32 -> Num.int32 -> bool

  end

  module Instance_Basic_classes_Eq_Num_int64 = struct

    val <> : Num.int64 -> Num.int64 -> bool
    val = : Num.int64 -> Num.int64 -> bool

  end

  module Instance_Basic_classes_Eq_Num_integer = struct

    val <> : Num.integer -> Num.integer -> bool
    val = : Num.integer -> Num.integer -> bool

  end

  module Instance_Basic_classes_Eq_Num_natural = struct

    val <> : Num.natural -> Num.natural -> bool
    val = : Num.natural -> Num.natural -> bool

  end

  module Instance_Basic_classes_Eq_nat = struct

    val <> : nat -> nat -> bool
    val = : nat -> nat -> bool

  end

  module Instance_Basic_classes_OrdMaxMin_Num_int = struct

    val max : Num.int -> Num.int -> Num.int
    val min : Num.int -> Num.int -> Num.int

  end

  module Instance_Basic_classes_OrdMaxMin_Num_int32 = struct

    val max : Num.int32 -> Num.int32 -> Num.int32
    val min : Num.int32 -> Num.int32 -> Num.int32

  end

  module Instance_Basic_classes_OrdMaxMin_Num_int64 = struct

    val max : Num.int64 -> Num.int64 -> Num.int64
    val min : Num.int64 -> Num.int64 -> Num.int64

  end

  module Instance_Basic_classes_OrdMaxMin_Num_integer = struct

    val max : Num.integer -> Num.integer -> Num.integer
    val min : Num.integer -> Num.integer -> Num.integer

  end

  module Instance_Basic_classes_OrdMaxMin_Num_natural = struct

    val max : Num.natural -> Num.natural -> Num.natural
    val min : Num.natural -> Num.natural -> Num.natural

  end

  module Instance_Basic_classes_OrdMaxMin_nat = struct

    val max : nat -> nat -> nat
    val min : nat -> nat -> nat

  end

  module Instance_Basic_classes_Ord_Num_int = struct

    val < : Num.int -> Num.int -> bool
    val <= : Num.int -> Num.int -> bool
    val > : Num.int -> Num.int -> bool
    val >= : Num.int -> Num.int -> bool
    val compare : Num.int -> Num.int -> Basic_classes.ordering

  end

  module Instance_Basic_classes_Ord_Num_int32 = struct

    val < : Num.int32 -> Num.int32 -> bool
    val <= : Num.int32 -> Num.int32 -> bool
    val > : Num.int32 -> Num.int32 -> bool
    val >= : Num.int32 -> Num.int32 -> bool
    val compare : Num.int32 -> Num.int32 -> Basic_classes.ordering

  end

  module Instance_Basic_classes_Ord_Num_int64 = struct

    val < : Num.int64 -> Num.int64 -> bool
    val <= : Num.int64 -> Num.int64 -> bool
    val > : Num.int64 -> Num.int64 -> bool
    val >= : Num.int64 -> Num.int64 -> bool
    val compare : Num.int64 -> Num.int64 -> Basic_classes.ordering

  end

  module Instance_Basic_classes_Ord_Num_integer = struct

    val < : Num.integer -> Num.integer -> bool
    val <= : Num.integer -> Num.integer -> bool
    val > : Num.integer -> Num.integer -> bool
    val >= : Num.integer -> Num.integer -> bool
    val compare : Num.integer -> Num.integer -> Basic_classes.ordering

  end

  module Instance_Basic_classes_Ord_Num_natural = struct

    val < : Num.natural -> Num.natural -> bool
    val <= : Num.natural -> Num.natural -> bool
    val > : Num.natural -> Num.natural -> bool
    val >= : Num.natural -> Num.natural -> bool
    val compare : Num.natural -> Num.natural -> Basic_classes.ordering

  end

  module Instance_Basic_classes_Ord_nat = struct

    val < : nat -> nat -> bool
    val <= : nat -> nat -> bool
    val > : nat -> nat -> bool
    val >= : nat -> nat -> bool
    val compare : nat -> nat -> Basic_classes.ordering

  end

  module Instance_Basic_classes_SetType_Num_int = struct

    val setElemCompare : Num.int -> Num.int -> Basic_classes.ordering

  end

  module Instance_Basic_classes_SetType_Num_int32 = struct

    val setElemCompare : Num.int32 -> Num.int32 -> Basic_classes.ordering

  end

  module Instance_Basic_classes_SetType_Num_int64 = struct

    val setElemCompare : Num.int64 -> Num.int64 -> Basic_classes.ordering

  end

  module Instance_Basic_classes_SetType_Num_integer = struct

    val setElemCompare : Num.integer -> Num.integer -> Basic_classes.ordering

  end

  module Instance_Basic_classes_SetType_Num_natural = struct

    val setElemCompare : Num.natural -> Num.natural -> Basic_classes.ordering

  end

  module Instance_Basic_classes_SetType_nat = struct

    val setElemCompare : nat -> nat -> Basic_classes.ordering

  end

  module Instance_Num_NumAbs_Num_int = struct

    val abs : Num.int -> Num.int

  end

  module Instance_Num_NumAbs_Num_int32 = struct

    val abs : Num.int32 -> Num.int32

  end

  module Instance_Num_NumAbs_Num_int64 = struct

    val abs : Num.int64 -> Num.int64

  end

  module Instance_Num_NumAbs_Num_integer = struct

    val abs : Num.integer -> Num.integer

  end

  module Instance_Num_NumAdd_Num_int = struct

    val + : Num.int -> Num.int -> Num.int

  end

  module Instance_Num_NumAdd_Num_int32 = struct

    val + : Num.int32 -> Num.int32 -> Num.int32

  end

  module Instance_Num_NumAdd_Num_int64 = struct

    val + : Num.int64 -> Num.int64 -> Num.int64

  end

  module Instance_Num_NumAdd_Num_integer = struct

    val + : Num.integer -> Num.integer -> Num.integer

  end

  module Instance_Num_NumAdd_Num_natural = struct

    val + : Num.natural -> Num.natural -> Num.natural

  end

  module Instance_Num_NumAdd_nat = struct

    val + : nat -> nat -> nat

  end

  module Instance_Num_NumDivision_Num_int = struct

    val / : Num.int -> Num.int -> Num.int

  end

  module Instance_Num_NumDivision_Num_int32 = struct

    val / : Num.int32 -> Num.int32 -> Num.int32

  end

  module Instance_Num_NumDivision_Num_int64 = struct

    val / : Num.int64 -> Num.int64 -> Num.int64

  end

  module Instance_Num_NumDivision_Num_integer = struct

    val / : Num.integer -> Num.integer -> Num.integer

  end

  module Instance_Num_NumDivision_Num_natural = struct

    val / : Num.natural -> Num.natural -> Num.natural

  end

  module Instance_Num_NumDivision_nat = struct

    val / : nat -> nat -> nat

  end

  module Instance_Num_NumIntegerDivision_Num_int = struct

    val div : Num.int -> Num.int -> Num.int

  end

  module Instance_Num_NumIntegerDivision_Num_int32 = struct

    val div : Num.int32 -> Num.int32 -> Num.int32

  end

  module Instance_Num_NumIntegerDivision_Num_int64 = struct

    val div : Num.int64 -> Num.int64 -> Num.int64

  end

  module Instance_Num_NumIntegerDivision_Num_integer = struct

    val div : Num.integer -> Num.integer -> Num.integer

  end

  module Instance_Num_NumIntegerDivision_Num_natural = struct

    val div : Num.natural -> Num.natural -> Num.natural

  end

  module Instance_Num_NumIntegerDivision_nat = struct

    val div : nat -> nat -> nat

  end

  module Instance_Num_NumMinus_Num_int = struct

    val - : Num.int -> Num.int -> Num.int

  end

  module Instance_Num_NumMinus_Num_int32 = struct

    val - : Num.int32 -> Num.int32 -> Num.int32

  end

  module Instance_Num_NumMinus_Num_int64 = struct

    val - : Num.int64 -> Num.int64 -> Num.int64

  end

  module Instance_Num_NumMinus_Num_integer = struct

    val - : Num.integer -> Num.integer -> Num.integer

  end

  module Instance_Num_NumMinus_Num_natural = struct

    val - : Num.natural -> Num.natural -> Num.natural

  end

  module Instance_Num_NumMinus_nat = struct

    val - : nat -> nat -> nat

  end

  module Instance_Num_NumMult_Num_int = struct

    val * : Num.int -> Num.int -> Num.int

  end

  module Instance_Num_NumMult_Num_int32 = struct

    val * : Num.int32 -> Num.int32 -> Num.int32

  end

  module Instance_Num_NumMult_Num_int64 = struct

    val * : Num.int64 -> Num.int64 -> Num.int64

  end

  module Instance_Num_NumMult_Num_integer = struct

    val * : Num.integer -> Num.integer -> Num.integer

  end

  module Instance_Num_NumMult_Num_natural = struct

    val * : Num.natural -> Num.natural -> Num.natural

  end

  module Instance_Num_NumMult_nat = struct

    val * : nat -> nat -> nat

  end

  module Instance_Num_NumNegate_Num_int = struct

    val ~ : Num.int -> Num.int

  end

  module Instance_Num_NumNegate_Num_int32 = struct

    val ~ : Num.int32 -> Num.int32

  end

  module Instance_Num_NumNegate_Num_int64 = struct

    val ~ : Num.int64 -> Num.int64

  end

  module Instance_Num_NumNegate_Num_integer = struct

    val ~ : Num.integer -> Num.integer

  end

  module Instance_Num_NumPow_Num_int = struct

    val ** : Num.int -> nat -> Num.int

  end

  module Instance_Num_NumPow_Num_int32 = struct

    val ** : Num.int32 -> nat -> Num.int32

  end

  module Instance_Num_NumPow_Num_int64 = struct

    val ** : Num.int64 -> nat -> Num.int64

  end

  module Instance_Num_NumPow_Num_integer = struct

    val ** : Num.integer -> nat -> Num.integer

  end

  module Instance_Num_NumPow_Num_natural = struct

    val ** : Num.natural -> nat -> Num.natural

  end

  module Instance_Num_NumPow_nat = struct

    val ** : nat -> nat -> nat

  end

  module Instance_Num_NumPred_Num_int = struct

    val pred : Num.int -> Num.int

  end

  module Instance_Num_NumPred_Num_int32 = struct

    val pred : Num.int32 -> Num.int32

  end

  module Instance_Num_NumPred_Num_int64 = struct

    val pred : Num.int64 -> Num.int64

  end

  module Instance_Num_NumPred_Num_integer = struct

    val pred : Num.integer -> Num.integer

  end

  module Instance_Num_NumPred_Num_natural = struct

    val pred : Num.natural -> Num.natural

  end

  module Instance_Num_NumPred_nat = struct

    val pred : nat -> nat

  end

  module Instance_Num_NumRemainder_Num_int = struct

    val mod : Num.int -> Num.int -> Num.int

  end

  module Instance_Num_NumRemainder_Num_int32 = struct

    val mod : Num.int32 -> Num.int32 -> Num.int32

  end

  module Instance_Num_NumRemainder_Num_int64 = struct

    val mod : Num.int64 -> Num.int64 -> Num.int64

  end

  module Instance_Num_NumRemainder_Num_integer = struct

    val mod : Num.integer -> Num.integer -> Num.integer

  end

  module Instance_Num_NumRemainder_Num_natural = struct

    val mod : Num.natural -> Num.natural -> Num.natural

  end

  module Instance_Num_NumRemainder_nat = struct

    val mod : nat -> nat -> nat

  end

  module Instance_Num_NumSucc_Num_int = struct

    val succ : Num.int -> Num.int

  end

  module Instance_Num_NumSucc_Num_int32 = struct

    val succ : Num.int32 -> Num.int32

  end

  module Instance_Num_NumSucc_Num_int64 = struct

    val succ : Num.int64 -> Num.int64

  end

  module Instance_Num_NumSucc_Num_integer = struct

    val succ : Num.integer -> Num.integer

  end

  module Instance_Num_NumSucc_Num_natural = struct

    val succ : Num.natural -> Num.natural

  end

  module Instance_Num_NumSucc_nat = struct

    val succ : nat -> nat

  end

  module Instance_Num_Numeral_Num_int = struct

    val fromNumeral : numeral -> Num.int

  end

  module Instance_Num_Numeral_Num_int32 = struct

    val fromNumeral : numeral -> Num.int32

  end

  module Instance_Num_Numeral_Num_int64 = struct

    val fromNumeral : numeral -> Num.int64

  end

  module Instance_Num_Numeral_Num_integer = struct

    val fromNumeral : numeral -> Num.integer

  end

  module Instance_Num_Numeral_Num_natural = struct

    val fromNumeral : numeral -> Num.natural

  end

  module Instance_Num_Numeral_nat = struct

    val fromNumeral : numeral -> nat

  end

end

module Pervasives = struct
  class Eq
  type Eq_class 'a = {
      val isEqual_method : forall 'a. 
                             (Basic_classes.Eq_class 'a) -> 'a -> 'a -> bool

      val isInequal_method : forall 'a. 
                               (Basic_classes.Eq_class 'a) -> 'a -> 'a -> 
                                                                    bool

  }
  class MapKeyType
  type MapKeyType_class 'a = {
      val mapKeyCompare_method : forall 'a. 
                                   (Map.MapKeyType_class 'a) -> 'a -> 
                                                                'a -> 
                                                                Basic_classes.ordering

  }
  class NumAbs
  type NumAbs_class 'a = {
      val abs_method : forall 'a. (Num.NumAbs_class 'a) -> 'a -> 'a

  }
  class NumAdd
  type NumAdd_class 'a = {
      val numAdd_method : forall 'a. (Num.NumAdd_class 'a) -> 'a -> 'a -> 'a

  }
  class NumDivision
  type NumDivision_class 'a = {
      val numDivision_method : forall 'a. 
                                 (Num.NumDivision_class 'a) -> 'a -> 'a -> 'a

  }
  class NumIntegerDivision
  type NumIntegerDivision_class 'a = {
      val div_method : forall 'a. 
                         (Num.NumIntegerDivision_class 'a) -> 'a -> 'a -> 'a

  }
  class NumMinus
  type NumMinus_class 'a = {
      val numMinus_method : forall 'a. 
                              (Num.NumMinus_class 'a) -> 'a -> 'a -> 'a

  }
  class NumMult
  type NumMult_class 'a = {
      val numMult_method : forall 'a. 
                             (Num.NumMult_class 'a) -> 'a -> 'a -> 'a

  }
  class NumNegate
  type NumNegate_class 'a = {
      val numNegate_method : forall 'a. (Num.NumNegate_class 'a) -> 'a -> 'a

  }
  class NumPow
  type NumPow_class 'a = {
      val numPow_method : forall 'a. (Num.NumPow_class 'a) -> 'a -> nat -> 'a

  }
  class NumPred
  type NumPred_class 'a = {
      val pred_method : forall 'a. (Num.NumPred_class 'a) -> 'a -> 'a

  }
  class NumRemainder
  type NumRemainder_class 'a = {
      val mod_method : forall 'a. 
                         (Num.NumRemainder_class 'a) -> 'a -> 'a -> 'a

  }
  class NumSucc
  type NumSucc_class 'a = {
      val succ_method : forall 'a. (Num.NumSucc_class 'a) -> 'a -> 'a

  }
  class Numeral
  type Numeral_class 'a = {
      val fromNumeral_method : forall 'a. 
                                 (Num.Numeral_class 'a) -> numeral -> 'a

  }
  class Ord
  class OrdMaxMin
  type OrdMaxMin_class 'a = {
      val max_method : forall 'a. 
                         (Basic_classes.OrdMaxMin_class 'a) -> 'a -> 'a -> 'a

      val min_method : forall 'a. 
                         (Basic_classes.OrdMaxMin_class 'a) -> 'a -> 'a -> 'a

  }
  type Ord_class 'a = {
      val compare_method : forall 'a. 
                             (Basic_classes.Ord_class 'a) -> 'a -> 'a -> 
                                                                   Basic_classes.ordering

      val isLess_method : forall 'a. 
                            (Basic_classes.Ord_class 'a) -> 'a -> 'a -> bool

      val isLessEqual_method : forall 'a. 
                                 (Basic_classes.Ord_class 'a) -> 'a -> 
                                                                 'a -> 
                                                                 bool

      val isGreater_method : forall 'a. 
                               (Basic_classes.Ord_class 'a) -> 'a -> 
                                                               'a -> 
                                                               bool

      val isGreaterEqual_method : forall 'a. 
                                    (Basic_classes.Ord_class 'a) -> 'a -> 
                                                                    'a -> 
                                                                    bool

  }
  class SetType
  type SetType_class 'a = {
      val setElemCompare_method : forall 'a. 
                                    (Basic_classes.SetType_class 'a) -> 
                                    'a -> 'a -> Basic_classes.ordering

  }
  class WordAnd
  type WordAnd_class 'a = {
      val land_method : forall 'a. (Word.WordAnd_class 'a) -> 'a -> 'a -> 'a

  }
  class WordAsr
  type WordAsr_class 'a = {
      val asr_method : forall 'a. (Word.WordAsr_class 'a) -> 'a -> nat -> 'a

  }
  class WordLsl
  type WordLsl_class 'a = {
      val lsl_method : forall 'a. (Word.WordLsl_class 'a) -> 'a -> nat -> 'a

  }
  class WordLsr
  type WordLsr_class 'a = {
      val lsr_method : forall 'a. (Word.WordLsr_class 'a) -> 'a -> nat -> 'a

  }
  class WordNot
  type WordNot_class 'a = {
      val lnot_method : forall 'a. (Word.WordNot_class 'a) -> 'a -> 'a

  }
  class WordOr
  type WordOr_class 'a = {
      val lor_method : forall 'a. (Word.WordOr_class 'a) -> 'a -> 'a -> 'a

  }
  class WordXor
  type WordXor_class 'a = {
      val lxor_method : forall 'a. (Word.WordXor_class 'a) -> 'a -> 'a -> 'a

  }
  type bitSequence
  type either 'a 'b
  type float32
  type float64
  type int
  type int32
  type int64
  type integer
  type map 'k 'v
  type maybe 'a
  type natural
  type ordering
  type rational

  val $ : forall 'a 'b. ('a -> 'b) -> 'a -> 'b
  val && : bool -> bool -> bool
  val * : forall 'a. (Num.NumMult 'a) => 'a -> 'a -> 'a
  val ** : forall 'a. (Num.NumPow 'a) => 'a -> nat -> 'a
  val + : forall 'a. (Num.NumAdd 'a) => 'a -> 'a -> 'a
  val ++ : forall 'a. (list 'a) -> (list 'a) -> list 'a
  val - : forall 'a. (Num.NumMinus 'a) => 'a -> 'a -> 'a
  val --> : bool -> bool -> bool
  val / : forall 'a. (Num.NumDivision 'a) => 'a -> 'a -> 'a
  val :: : forall 'a. 'a -> (list 'a) -> list 'a
  val < : forall 'a. (Basic_classes.Ord 'a) => 'a -> 'a -> bool
  val <-> : bool -> bool -> bool
  val <= : forall 'a. (Basic_classes.Ord 'a) => 'a -> 'a -> bool
  val <> : forall 'a. (Basic_classes.Eq 'a) => 'a -> 'a -> bool
  val = : forall 'a. (Basic_classes.Eq 'a) => 'a -> 'a -> bool
  val > : forall 'a. (Basic_classes.Ord 'a) => 'a -> 'a -> bool
  val >= : forall 'a. (Basic_classes.Ord 'a) => 'a -> 'a -> bool
  val BitSeq : (Maybe.maybe nat) -> bool -> (list bool) -> Word.bitSequence
  val EQ : Basic_classes.ordering
  val GT : Basic_classes.ordering
  val IN : forall 'a. (Basic_classes.SetType 'a) => 'a -> (set 'a) -> bool
  val Just : forall 'a. 'a -> Maybe.maybe 'a
  val LT : Basic_classes.ordering
  val Left : forall 'a 'b. 'a -> Either.either 'a 'b
  val NIN : forall 'a. (Basic_classes.SetType 'a) => 'a -> (set 'a) -> bool
  val Nothing : forall 'a. Maybe.maybe 'a
  val Right : forall 'a 'b. 'b -> Either.either 'a 'b
  val \ : forall 'a. 
            (Basic_classes.SetType 'a) => (set 'a) -> (set 'a) -> set 'a
  val ^ : string -> string -> string
  val abs : forall 'a. (Num.NumAbs 'a) => 'a -> 'a
  val all : forall 'a. ('a -> bool) -> (list 'a) -> bool
  val and : bool -> bool -> bool
  val any : forall 'a. ('a -> bool) -> (list 'a) -> bool
  val append : forall 'a. (list 'a) -> (list 'a) -> list 'a
  val apply : forall 'a 'b. ('a -> 'b) -> 'a -> 'b
  val arithmetic_right_shift : forall 'a. 
                                 (Word.WordAsr 'a) => 'a -> nat -> 'a
  val asr : forall 'a. (Word.WordAsr 'a) => 'a -> nat -> 'a
  val bigunion : forall 'a. 
                   (Basic_classes.SetType 'a) => (set (set 'a)) -> set 'a
  val bigunionBy : forall 'a. 
                     ('a -> 'a -> Basic_classes.ordering) -> (set (set 'a)) -> 
                                                             set 'a
  val bind : forall 'a 'b. 
               (Maybe.maybe 'a) -> ('a -> Maybe.maybe 'b) -> Maybe.maybe 'b
  val bitSeqAdd : Word.bitSequence -> Word.bitSequence -> Word.bitSequence
  val bitSeqAnd : Word.bitSequence -> Word.bitSequence -> Word.bitSequence
  val bitSeqArithBinOp : 
                           (Num.integer -> Num.integer -> Num.integer) -> 
                           Word.bitSequence -> Word.bitSequence -> Word.bitSequence
  val bitSeqArithBinTest : forall 'a. 
                             (Num.integer -> Num.integer -> 'a) -> Word.bitSequence -> 
                                                                   Word.bitSequence -> 
                                                                   'a
  val bitSeqArithUnaryOp : 
                             (Num.integer -> Num.integer) -> Word.bitSequence -> 
                                                             Word.bitSequence
  val bitSeqArithmeticShiftRight : 
                                     Word.bitSequence -> nat -> Word.bitSequence
  val bitSeqBinop : 
                      (bool -> bool -> bool) -> Word.bitSequence -> Word.bitSequence -> 
                                                                    Word.bitSequence
  val bitSeqBinopAux : 
                         (bool -> bool -> bool) -> bool -> (list bool) -> 
                                                           bool -> (list 
                                                                   bool) -> 
                                                                   list 
                                                                   bool
  val bitSeqCompare : 
                        Word.bitSequence -> Word.bitSequence -> Basic_classes.ordering
  val bitSeqDiv : Word.bitSequence -> Word.bitSequence -> Word.bitSequence
  val bitSeqEq : Word.bitSequence -> Word.bitSequence -> bool
  val bitSeqFromBoolList : (list bool) -> Maybe.maybe Word.bitSequence
  val bitSeqFromInt : Num.int -> Word.bitSequence
  val bitSeqFromInteger : 
                            (Maybe.maybe nat) -> Num.integer -> Word.bitSequence
  val bitSeqFromNat : nat -> Word.bitSequence
  val bitSeqFromNatural : 
                            (Maybe.maybe nat) -> Num.natural -> Word.bitSequence
  val bitSeqFromNumeral : numeral -> Word.bitSequence
  val bitSeqGreater : Word.bitSequence -> Word.bitSequence -> bool
  val bitSeqGreaterEqual : Word.bitSequence -> Word.bitSequence -> bool
  val bitSeqLess : Word.bitSequence -> Word.bitSequence -> bool
  val bitSeqLessEqual : Word.bitSequence -> Word.bitSequence -> bool
  val bitSeqLogicalShiftRight : Word.bitSequence -> nat -> Word.bitSequence
  val bitSeqMax : Word.bitSequence -> Word.bitSequence -> Word.bitSequence
  val bitSeqMin : Word.bitSequence -> Word.bitSequence -> Word.bitSequence
  val bitSeqMinus : Word.bitSequence -> Word.bitSequence -> Word.bitSequence
  val bitSeqMod : Word.bitSequence -> Word.bitSequence -> Word.bitSequence
  val bitSeqMult : Word.bitSequence -> Word.bitSequence -> Word.bitSequence
  val bitSeqNegate : Word.bitSequence -> Word.bitSequence
  val bitSeqNot : Word.bitSequence -> Word.bitSequence
  val bitSeqOr : Word.bitSequence -> Word.bitSequence -> Word.bitSequence
  val bitSeqPow : Word.bitSequence -> nat -> Word.bitSequence
  val bitSeqPred : Word.bitSequence -> Word.bitSequence
  val bitSeqSetBit : Word.bitSequence -> nat -> bool -> Word.bitSequence
  val bitSeqShiftLeft : Word.bitSequence -> nat -> Word.bitSequence
  val bitSeqSucc : Word.bitSequence -> Word.bitSequence
  val bitSeqTestBit : Word.bitSequence -> nat -> Maybe.maybe bool
  val bitSeqXor : Word.bitSequence -> Word.bitSequence -> Word.bitSequence
  val boolCompare : bool -> bool -> Basic_classes.ordering
  val boolListFromInteger : Num.integer -> (bool * (list bool))
  val boolListFromIntegerAux : (list bool) -> Num.integer -> list bool
  val boolListFromNatural : (list bool) -> Num.natural -> list bool
  val boolListFrombitSeq : nat -> Word.bitSequence -> list bool
  val boolListFrombitSeqAux : forall 'a. nat -> 'a -> (list 'a) -> list 'a
  val cleanBitSeq : Word.bitSequence -> Word.bitSequence
  val comb : forall 'a 'b 'c. ('b -> 'c) -> ('a -> 'b) -> 'a -> 'c
  val compare : forall 'a. 
                  (Basic_classes.Ord 'a) => 
                    'a -> 'a -> Basic_classes.ordering
  val concat : forall 'a. (list (list 'a)) -> list 'a
  val concatMap : forall 'a 'b. ('a -> list 'b) -> (list 'a) -> list 'b
  val conjunction : forall 'a. (Word.WordAnd 'a) => 'a -> 'a -> 'a
  val cons : forall 'a. 'a -> (list 'a) -> list 'a
  val cons_string : char -> string -> string
  val const : forall 'a 'b. 'a -> 'b -> 'a
  val cross : forall 'a 'b. 
                (Basic_classes.SetType 'a) (Basic_classes.SetType 'b) => 
                  (set 'a) -> (set 'b) -> set ('a * 'b)
  val crossBy : forall 'a 'b. 
                  (('a * 'b) -> ('a * 'b) -> Basic_classes.ordering) -> 
                  (set 'a) -> (set 'b) -> set ('a * 'b)
  val curry : forall 'a 'b 'c. (('a * 'b) -> 'c) -> 'a -> 'b -> 'c
  val defaultAsr : forall 'a. 
                     (Word.bitSequence -> 'a) -> ('a -> Word.bitSequence) -> 
                                                 'a -> nat -> 'a
  val defaultCompare : forall 'a. 'a -> 'a -> Basic_classes.ordering
  val defaultGreater : forall 'a. 'a -> 'a -> bool
  val defaultGreaterEq : forall 'a. 'a -> 'a -> bool
  val defaultLand : forall 'a. 
                      (Word.bitSequence -> 'a) -> ('a -> Word.bitSequence) -> 
                                                  'a -> 'a -> 'a
  val defaultLess : forall 'a. 'a -> 'a -> bool
  val defaultLessEq : forall 'a. 'a -> 'a -> bool
  val defaultLnot : forall 'a. 
                      (Word.bitSequence -> 'a) -> ('a -> Word.bitSequence) -> 
                                                  'a -> 'a
  val defaultLor : forall 'a. 
                     (Word.bitSequence -> 'a) -> ('a -> Word.bitSequence) -> 
                                                 'a -> 'a -> 'a
  val defaultLsl : forall 'a. 
                     (Word.bitSequence -> 'a) -> ('a -> Word.bitSequence) -> 
                                                 'a -> nat -> 'a
  val defaultLsr : forall 'a. 
                     (Word.bitSequence -> 'a) -> ('a -> Word.bitSequence) -> 
                                                 'a -> nat -> 'a
  val defaultLxor : forall 'a. 
                      (Word.bitSequence -> 'a) -> ('a -> Word.bitSequence) -> 
                                                  'a -> 'a -> 'a
  val defaultMax : forall 'a. (Basic_classes.Ord 'a) => 'a -> 'a -> 'a
  val defaultMin : forall 'a. (Basic_classes.Ord 'a) => 'a -> 'a -> 'a
  val delete : forall 'a. (Basic_classes.Eq 'a) => 'a -> (list 'a) -> list 'a
  val deleteBy : forall 'a. ('a -> 'a -> bool) -> 'a -> (list 'a) -> list 'a
  val deleteFirst : forall 'a. 
                      ('a -> bool) -> (list 'a) -> Maybe.maybe (list 'a)
  val deleteSwap : forall 'k 'v. 
                     (Map.MapKeyType 'k) => 
                       (Map.map 'k 'v) -> 'k -> Map.map 'k 'v
  val dest_init : forall 'a. (list 'a) -> Maybe.maybe ((list 'a) * 'a)
  val dest_init_aux : forall 'a. 
                        (list 'a) -> 'a -> (list 'a) -> ((list 'a) * 'a)
  val difference : forall 'a. 
                     (Basic_classes.SetType 'a) => 
                       (set 'a) -> (set 'a) -> set 'a
  val differenceBy : forall 'a. 
                       ('a -> 'a -> Basic_classes.ordering) -> (set 'a) -> 
                                                               (set 'a) -> 
                                                               set 'a
  val div : forall 'a. (Num.NumIntegerDivision 'a) => 'a -> 'a -> 'a
  val domain : forall 'k 'v. 
                 (Map.MapKeyType 'k) (Basic_classes.SetType 'k) => 
                   (Map.map 'k 'v) -> set 'k
  val domainBy : forall 'k 'v. 
                   ('k -> 'k -> Basic_classes.ordering) -> (Map.map 'k 'v) -> 
                                                           set 'k
  val drop : forall 'a. nat -> (list 'a) -> list 'a
  val dropWhile : forall 'a. ('a -> bool) -> (list 'a) -> list 'a
  val either : forall 'a 'b 'c. 
                 ('a -> 'c) -> ('b -> 'c) -> (Either.either 'a 'b) -> 'c
  val eitherEqual : forall 'a 'b. 
                      (Basic_classes.Eq 'a) (Basic_classes.Eq 'b) => 
                        (Either.either 'a 'b) -> (Either.either 'a 'b) -> 
                                                 bool
  val eitherEqualBy : forall 'a 'b. 
                        ('a -> 'a -> bool) -> ('b -> 'b -> bool) -> (Either.either 
                                                                    'a 
                                                                    'b) -> 
                                                                    (Either.either 
                                                                    'a 
                                                                    'b) -> 
                                                                    bool
  val elem : forall 'a. (Basic_classes.Eq 'a) => 'a -> (list 'a) -> bool
  val elemBy : forall 'a. ('a -> 'a -> bool) -> 'a -> (list 'a) -> bool
  val elemIndex : forall 'a. 
                    (Basic_classes.Eq 'a) => 
                      'a -> (list 'a) -> Maybe.maybe nat
  val elemIndices : forall 'a. 
                      (Basic_classes.Eq 'a) => 'a -> (list 'a) -> list nat
  val empty : forall 'a. (Basic_classes.SetType 'a) => set 'a
  val emptyBy : forall 'a. ('a -> 'a -> Basic_classes.ordering) -> set 'a
  val empty_string : string
  val equiv : bool -> bool -> bool
  val exclusive_or : forall 'a. (Word.WordXor 'a) => 'a -> 'a -> 'a
  val filter : forall 'a. ('a -> bool) -> (list 'a) -> list 'a
  val find : forall 'a. ('a -> bool) -> (list 'a) -> Maybe.maybe 'a
  val findIndex : forall 'a. ('a -> bool) -> (list 'a) -> Maybe.maybe nat
  val findIndices : forall 'a. ('a -> bool) -> (list 'a) -> list nat
  val findIndices_aux : forall 'a. 
                          nat -> ('a -> bool) -> (list 'a) -> list nat
  val findMax : forall 'a. 
                  (Basic_classes.SetType 'a) (Basic_classes.Eq 'a) => 
                    (set 'a) -> Maybe.maybe 'a
  val findMin : forall 'a. 
                  (Basic_classes.SetType 'a) (Basic_classes.Eq 'a) => 
                    (set 'a) -> Maybe.maybe 'a
  val findWithDefault : forall 'k 'v. 
                          (Map.MapKeyType 'k) => 
                            'k -> 'v -> (Map.map 'k 'v) -> 'v
  val finite : forall 'a. (Basic_classes.SetType 'a) => (set 'a) -> bool
  val flip : forall 'a 'b 'c. ('a -> 'b -> 'c) -> 'b -> 'a -> 'c
  val foldl : forall 'a 'b. ('a -> 'b -> 'a) -> 'a -> (list 'b) -> 'a
  val foldr : forall 'a 'b. ('a -> 'b -> 'b) -> 'b -> (list 'a) -> 'b
  val fromList : forall 'a. (Basic_classes.SetType 'a) => (list 'a) -> set 'a
  val fromListBy : forall 'a. 
                     ('a -> 'a -> Basic_classes.ordering) -> (list 'a) -> 
                                                             set 'a
  val fromMaybe : forall 'a. 'a -> (Maybe.maybe 'a) -> 'a
  val fromNumeral : forall 'a. (Num.Numeral 'a) => numeral -> 'a
  val fst : forall 'a 'b. ('a * 'b) -> 'a
  val gen_pow : forall 'a. 'a -> ('a -> 'a -> 'a) -> 'a -> nat -> 'a
  val gen_pow_aux : forall 'a. ('a -> 'a -> 'a) -> 'a -> 'a -> nat -> 'a
  val genericCompare : forall 'a. 
                         ('a -> 'a -> bool) -> ('a -> 'a -> bool) -> 
                                               'a -> 'a -> Basic_classes.ordering
  val genlist : forall 'a. (nat -> 'a) -> nat -> list 'a
  val id : forall 'a. 'a -> 'a
  val imp : bool -> bool -> bool
  val inclusive_or : forall 'a. (Word.WordOr 'a) => 'a -> 'a -> 'a
  val index : forall 'a. (list 'a) -> nat -> Maybe.maybe 'a
  val insert : forall 'a. 
                 (Basic_classes.SetType 'a) => 'a -> (set 'a) -> set 'a
  val instance_Basic_classes_Eq_Basic_classes_ordering_dict : 
                                                                Basic_classes.Eq_class 
                                                                Basic_classes.ordering
  val instance_Basic_classes_Eq_Either_either_dict : forall 'a 'b. 
                                                       (Basic_classes.Eq 'a)
                                                         (Basic_classes.Eq 'b) => 
                                                         Basic_classes.Eq_class 
                                                         (Either.either 
                                                         'a 'b)
  val instance_Basic_classes_Eq_Map_map_dict : forall 'k 'v. 
                                                 (Basic_classes.Eq 'k)
                                                   (Basic_classes.Eq 'v) => 
                                                   Basic_classes.Eq_class 
                                                   (Map.map 'k 'v)
  val instance_Basic_classes_Eq_Maybe_maybe_dict : forall 'a. 
                                                     (Basic_classes.Eq 'a) => 
                                                       Basic_classes.Eq_class 
                                                       (Maybe.maybe 'a)
  val instance_Basic_classes_Eq_Num_int32_dict : 
                                                   Basic_classes.Eq_class 
                                                   Num.int32
  val instance_Basic_classes_Eq_Num_int64_dict : 
                                                   Basic_classes.Eq_class 
                                                   Num.int64
  val instance_Basic_classes_Eq_Num_int_dict : Basic_classes.Eq_class Num.int
  val instance_Basic_classes_Eq_Num_integer_dict : 
                                                     Basic_classes.Eq_class 
                                                     Num.integer
  val instance_Basic_classes_Eq_Num_natural_dict : 
                                                     Basic_classes.Eq_class 
                                                     Num.natural
  val instance_Basic_classes_Eq_Word_bitSequence_dict : 
                                                          Basic_classes.Eq_class 
                                                          Word.bitSequence
  val instance_Basic_classes_Eq_bool_dict : Basic_classes.Eq_class bool
  val instance_Basic_classes_Eq_list_dict : forall 'a. 
                                              (Basic_classes.Eq 'a) => 
                                                Basic_classes.Eq_class 
                                                (list 'a)
  val instance_Basic_classes_Eq_nat_dict : Basic_classes.Eq_class nat
  val instance_Basic_classes_Eq_set_dict : forall 'a. 
                                             (Basic_classes.SetType 'a) => 
                                               Basic_classes.Eq_class 
                                               (set 'a)
  val instance_Basic_classes_Eq_tup2_dict : forall 'a 'b. 
                                              (Basic_classes.Eq 'a)
                                                (Basic_classes.Eq 'b) => 
                                                Basic_classes.Eq_class 
                                                ('a * 'b)
  val instance_Basic_classes_Eq_tup3_dict : forall 'a 'b 'c. 
                                              (Basic_classes.Eq 'a)
                                                (Basic_classes.Eq 'b)
                                                (Basic_classes.Eq 'c) => 
                                                Basic_classes.Eq_class 
                                                ('a * 'b * 'c)
  val instance_Basic_classes_Eq_var_dict : forall 'a. 
                                             Basic_classes.Eq_class 'a
  val instance_Basic_classes_OrdMaxMin_Num_int32_dict : 
                                                          Basic_classes.OrdMaxMin_class 
                                                          Num.int32
  val instance_Basic_classes_OrdMaxMin_Num_int64_dict : 
                                                          Basic_classes.OrdMaxMin_class 
                                                          Num.int64
  val instance_Basic_classes_OrdMaxMin_Num_int_dict : 
                                                        Basic_classes.OrdMaxMin_class 
                                                        Num.int
  val instance_Basic_classes_OrdMaxMin_Num_integer_dict : 
                                                            Basic_classes.OrdMaxMin_class 
                                                            Num.integer
  val instance_Basic_classes_OrdMaxMin_Num_natural_dict : 
                                                            Basic_classes.OrdMaxMin_class 
                                                            Num.natural
  val instance_Basic_classes_OrdMaxMin_Word_bitSequence_dict : 
                                                                 Basic_classes.OrdMaxMin_class 
                                                                 Word.bitSequence
  val instance_Basic_classes_OrdMaxMin_nat_dict : 
                                                    Basic_classes.OrdMaxMin_class 
                                                    nat
  val instance_Basic_classes_OrdMaxMin_var_dict : forall 'a. 
                                                    (Basic_classes.Ord 'a) => 
                                                      Basic_classes.OrdMaxMin_class 
                                                      'a
  val instance_Basic_classes_Ord_Num_int32_dict : 
                                                    Basic_classes.Ord_class 
                                                    Num.int32
  val instance_Basic_classes_Ord_Num_int64_dict : 
                                                    Basic_classes.Ord_class 
                                                    Num.int64
  val instance_Basic_classes_Ord_Num_int_dict : 
                                                  Basic_classes.Ord_class 
                                                  Num.int
  val instance_Basic_classes_Ord_Num_integer_dict : 
                                                      Basic_classes.Ord_class 
                                                      Num.integer
  val instance_Basic_classes_Ord_Num_natural_dict : 
                                                      Basic_classes.Ord_class 
                                                      Num.natural
  val instance_Basic_classes_Ord_Word_bitSequence_dict : 
                                                           Basic_classes.Ord_class 
                                                           Word.bitSequence
  val instance_Basic_classes_Ord_list_dict : forall 'a. 
                                               (Basic_classes.Ord 'a) => 
                                                 Basic_classes.Ord_class 
                                                 (list 'a)
  val instance_Basic_classes_Ord_nat_dict : Basic_classes.Ord_class nat
  val instance_Basic_classes_Ord_tup2_dict : forall 'a 'b. 
                                               (Basic_classes.Ord 'a)
                                                 (Basic_classes.Ord 'b) => 
                                                 Basic_classes.Ord_class 
                                                 ('a * 'b)
  val instance_Basic_classes_Ord_tup3_dict : forall 'a 'b 'c. 
                                               (Basic_classes.Ord 'a)
                                                 (Basic_classes.Ord 'b)
                                                 (Basic_classes.Ord 'c) => 
                                                 Basic_classes.Ord_class 
                                                 ('a * 'b * 'c)
  val instance_Basic_classes_SetType_Maybe_maybe_dict : forall 'a. 
                                                          (Basic_classes.SetType
                                                           'a) => 
                                                            Basic_classes.SetType_class 
                                                            (Maybe.maybe 'a)
  val instance_Basic_classes_SetType_Num_int32_dict : 
                                                        Basic_classes.SetType_class 
                                                        Num.int32
  val instance_Basic_classes_SetType_Num_int64_dict : 
                                                        Basic_classes.SetType_class 
                                                        Num.int64
  val instance_Basic_classes_SetType_Num_int_dict : 
                                                      Basic_classes.SetType_class 
                                                      Num.int
  val instance_Basic_classes_SetType_Num_integer_dict : 
                                                          Basic_classes.SetType_class 
                                                          Num.integer
  val instance_Basic_classes_SetType_Num_natural_dict : 
                                                          Basic_classes.SetType_class 
                                                          Num.natural
  val instance_Basic_classes_SetType_Word_bitSequence_dict : 
                                                               Basic_classes.SetType_class 
                                                               Word.bitSequence
  val instance_Basic_classes_SetType_bool_dict : 
                                                   Basic_classes.SetType_class 
                                                   bool
  val instance_Basic_classes_SetType_list_dict : forall 'a. 
                                                   (Basic_classes.SetType 'a) => 
                                                     Basic_classes.SetType_class 
                                                     (list 'a)
  val instance_Basic_classes_SetType_nat_dict : 
                                                  Basic_classes.SetType_class 
                                                  nat
  val instance_Basic_classes_SetType_set_dict : forall 'a. 
                                                  (Basic_classes.SetType 'a) => 
                                                    Basic_classes.SetType_class 
                                                    (set 'a)
  val instance_Basic_classes_SetType_tup2_dict : forall 'a 'b. 
                                                   (Basic_classes.SetType 'a)
                                                     (Basic_classes.SetType
                                                      'b) => 
                                                     Basic_classes.SetType_class 
                                                     ('a * 'b)
  val instance_Basic_classes_SetType_tup3_dict : forall 'a 'b 'c. 
                                                   (Basic_classes.SetType 'a)
                                                     (Basic_classes.SetType
                                                      'b)
                                                     (Basic_classes.SetType
                                                      'c) => 
                                                     Basic_classes.SetType_class 
                                                     ('a * 'b * 'c)
  val instance_Basic_classes_SetType_var_dict : forall 'a. 
                                                  Basic_classes.SetType_class 
                                                  'a
  val instance_Map_MapKeyType_var_dict : forall 'a. 
                                           (Basic_classes.SetType 'a) => 
                                             Map.MapKeyType_class 'a
  val instance_Num_NumAbs_Num_int32_dict : Num.NumAbs_class Num.int32
  val instance_Num_NumAbs_Num_int64_dict : Num.NumAbs_class Num.int64
  val instance_Num_NumAbs_Num_int_dict : Num.NumAbs_class Num.int
  val instance_Num_NumAbs_Num_integer_dict : Num.NumAbs_class Num.integer
  val instance_Num_NumAdd_Num_int32_dict : Num.NumAdd_class Num.int32
  val instance_Num_NumAdd_Num_int64_dict : Num.NumAdd_class Num.int64
  val instance_Num_NumAdd_Num_int_dict : Num.NumAdd_class Num.int
  val instance_Num_NumAdd_Num_integer_dict : Num.NumAdd_class Num.integer
  val instance_Num_NumAdd_Num_natural_dict : Num.NumAdd_class Num.natural
  val instance_Num_NumAdd_Word_bitSequence_dict : 
                                                    Num.NumAdd_class 
                                                    Word.bitSequence
  val instance_Num_NumAdd_nat_dict : Num.NumAdd_class nat
  val instance_Num_NumDivision_Num_int32_dict : 
                                                  Num.NumDivision_class 
                                                  Num.int32
  val instance_Num_NumDivision_Num_int64_dict : 
                                                  Num.NumDivision_class 
                                                  Num.int64
  val instance_Num_NumDivision_Num_int_dict : Num.NumDivision_class Num.int
  val instance_Num_NumDivision_Num_integer_dict : 
                                                    Num.NumDivision_class 
                                                    Num.integer
  val instance_Num_NumDivision_Num_natural_dict : 
                                                    Num.NumDivision_class 
                                                    Num.natural
  val instance_Num_NumDivision_Word_bitSequence_dict : 
                                                         Num.NumDivision_class 
                                                         Word.bitSequence
  val instance_Num_NumDivision_nat_dict : Num.NumDivision_class nat
  val instance_Num_NumIntegerDivision_Num_int32_dict : 
                                                         Num.NumIntegerDivision_class 
                                                         Num.int32
  val instance_Num_NumIntegerDivision_Num_int64_dict : 
                                                         Num.NumIntegerDivision_class 
                                                         Num.int64
  val instance_Num_NumIntegerDivision_Num_int_dict : 
                                                       Num.NumIntegerDivision_class 
                                                       Num.int
  val instance_Num_NumIntegerDivision_Num_integer_dict : 
                                                           Num.NumIntegerDivision_class 
                                                           Num.integer
  val instance_Num_NumIntegerDivision_Num_natural_dict : 
                                                           Num.NumIntegerDivision_class 
                                                           Num.natural
  val instance_Num_NumIntegerDivision_Word_bitSequence_dict : 
                                                                Num.NumIntegerDivision_class 
                                                                Word.bitSequence
  val instance_Num_NumIntegerDivision_nat_dict : 
                                                   Num.NumIntegerDivision_class 
                                                   nat
  val instance_Num_NumMinus_Num_int32_dict : Num.NumMinus_class Num.int32
  val instance_Num_NumMinus_Num_int64_dict : Num.NumMinus_class Num.int64
  val instance_Num_NumMinus_Num_int_dict : Num.NumMinus_class Num.int
  val instance_Num_NumMinus_Num_integer_dict : Num.NumMinus_class Num.integer
  val instance_Num_NumMinus_Num_natural_dict : Num.NumMinus_class Num.natural
  val instance_Num_NumMinus_Word_bitSequence_dict : 
                                                      Num.NumMinus_class 
                                                      Word.bitSequence
  val instance_Num_NumMinus_nat_dict : Num.NumMinus_class nat
  val instance_Num_NumMult_Num_int32_dict : Num.NumMult_class Num.int32
  val instance_Num_NumMult_Num_int64_dict : Num.NumMult_class Num.int64
  val instance_Num_NumMult_Num_int_dict : Num.NumMult_class Num.int
  val instance_Num_NumMult_Num_integer_dict : Num.NumMult_class Num.integer
  val instance_Num_NumMult_Num_natural_dict : Num.NumMult_class Num.natural
  val instance_Num_NumMult_Word_bitSequence_dict : 
                                                     Num.NumMult_class 
                                                     Word.bitSequence
  val instance_Num_NumMult_nat_dict : Num.NumMult_class nat
  val instance_Num_NumNegate_Num_int32_dict : Num.NumNegate_class Num.int32
  val instance_Num_NumNegate_Num_int64_dict : Num.NumNegate_class Num.int64
  val instance_Num_NumNegate_Num_int_dict : Num.NumNegate_class Num.int
  val instance_Num_NumNegate_Num_integer_dict : 
                                                  Num.NumNegate_class 
                                                  Num.integer
  val instance_Num_NumNegate_Word_bitSequence_dict : 
                                                       Num.NumNegate_class 
                                                       Word.bitSequence
  val instance_Num_NumPow_Num_int32_dict : Num.NumPow_class Num.int32
  val instance_Num_NumPow_Num_int64_dict : Num.NumPow_class Num.int64
  val instance_Num_NumPow_Num_int_dict : Num.NumPow_class Num.int
  val instance_Num_NumPow_Num_integer_dict : Num.NumPow_class Num.integer
  val instance_Num_NumPow_Num_natural_dict : Num.NumPow_class Num.natural
  val instance_Num_NumPow_Word_bitSequence_dict : 
                                                    Num.NumPow_class 
                                                    Word.bitSequence
  val instance_Num_NumPow_nat_dict : Num.NumPow_class nat
  val instance_Num_NumPred_Num_int32_dict : Num.NumPred_class Num.int32
  val instance_Num_NumPred_Num_int64_dict : Num.NumPred_class Num.int64
  val instance_Num_NumPred_Num_int_dict : Num.NumPred_class Num.int
  val instance_Num_NumPred_Num_integer_dict : Num.NumPred_class Num.integer
  val instance_Num_NumPred_Num_natural_dict : Num.NumPred_class Num.natural
  val instance_Num_NumPred_Word_bitSequence_dict : 
                                                     Num.NumPred_class 
                                                     Word.bitSequence
  val instance_Num_NumPred_nat_dict : Num.NumPred_class nat
  val instance_Num_NumRemainder_Num_int32_dict : 
                                                   Num.NumRemainder_class 
                                                   Num.int32
  val instance_Num_NumRemainder_Num_int64_dict : 
                                                   Num.NumRemainder_class 
                                                   Num.int64
  val instance_Num_NumRemainder_Num_int_dict : Num.NumRemainder_class Num.int
  val instance_Num_NumRemainder_Num_integer_dict : 
                                                     Num.NumRemainder_class 
                                                     Num.integer
  val instance_Num_NumRemainder_Num_natural_dict : 
                                                     Num.NumRemainder_class 
                                                     Num.natural
  val instance_Num_NumRemainder_Word_bitSequence_dict : 
                                                          Num.NumRemainder_class 
                                                          Word.bitSequence
  val instance_Num_NumRemainder_nat_dict : Num.NumRemainder_class nat
  val instance_Num_NumSucc_Num_int32_dict : Num.NumSucc_class Num.int32
  val instance_Num_NumSucc_Num_int64_dict : Num.NumSucc_class Num.int64
  val instance_Num_NumSucc_Num_int_dict : Num.NumSucc_class Num.int
  val instance_Num_NumSucc_Num_integer_dict : Num.NumSucc_class Num.integer
  val instance_Num_NumSucc_Num_natural_dict : Num.NumSucc_class Num.natural
  val instance_Num_NumSucc_Word_bitSequence_dict : 
                                                     Num.NumSucc_class 
                                                     Word.bitSequence
  val instance_Num_NumSucc_nat_dict : Num.NumSucc_class nat
  val instance_Num_Numeral_Num_int32_dict : Num.Numeral_class Num.int32
  val instance_Num_Numeral_Num_int64_dict : Num.Numeral_class Num.int64
  val instance_Num_Numeral_Num_int_dict : Num.Numeral_class Num.int
  val instance_Num_Numeral_Num_integer_dict : Num.Numeral_class Num.integer
  val instance_Num_Numeral_Num_natural_dict : Num.Numeral_class Num.natural
  val instance_Num_Numeral_Word_bitSequence_dict : 
                                                     Num.Numeral_class 
                                                     Word.bitSequence
  val instance_Num_Numeral_nat_dict : Num.Numeral_class nat
  val instance_Word_WordAnd_Num_int32_dict : Word.WordAnd_class Num.int32
  val instance_Word_WordAnd_Num_int64_dict : Word.WordAnd_class Num.int64
  val instance_Word_WordAnd_Num_int_dict : Word.WordAnd_class Num.int
  val instance_Word_WordAnd_Num_integer_dict : Word.WordAnd_class Num.integer
  val instance_Word_WordAnd_Num_natural_dict : Word.WordAnd_class Num.natural
  val instance_Word_WordAnd_Word_bitSequence_dict : 
                                                      Word.WordAnd_class 
                                                      Word.bitSequence
  val instance_Word_WordAnd_nat_dict : Word.WordAnd_class nat
  val instance_Word_WordAsr_Num_int32_dict : Word.WordAsr_class Num.int32
  val instance_Word_WordAsr_Num_int64_dict : Word.WordAsr_class Num.int64
  val instance_Word_WordAsr_Num_int_dict : Word.WordAsr_class Num.int
  val instance_Word_WordAsr_Num_integer_dict : Word.WordAsr_class Num.integer
  val instance_Word_WordAsr_Num_natural_dict : Word.WordAsr_class Num.natural
  val instance_Word_WordAsr_Word_bitSequence_dict : 
                                                      Word.WordAsr_class 
                                                      Word.bitSequence
  val instance_Word_WordAsr_nat_dict : Word.WordAsr_class nat
  val instance_Word_WordLsl_Num_int32_dict : Word.WordLsl_class Num.int32
  val instance_Word_WordLsl_Num_int64_dict : Word.WordLsl_class Num.int64
  val instance_Word_WordLsl_Num_int_dict : Word.WordLsl_class Num.int
  val instance_Word_WordLsl_Num_integer_dict : Word.WordLsl_class Num.integer
  val instance_Word_WordLsl_Num_natural_dict : Word.WordLsl_class Num.natural
  val instance_Word_WordLsl_Word_bitSequence_dict : 
                                                      Word.WordLsl_class 
                                                      Word.bitSequence
  val instance_Word_WordLsl_nat_dict : Word.WordLsl_class nat
  val instance_Word_WordLsr_Num_int32_dict : Word.WordLsr_class Num.int32
  val instance_Word_WordLsr_Num_int64_dict : Word.WordLsr_class Num.int64
  val instance_Word_WordLsr_Num_integer_dict : Word.WordLsr_class Num.integer
  val instance_Word_WordLsr_Num_natural_dict : Word.WordLsr_class Num.natural
  val instance_Word_WordLsr_Word_bitSequence_dict : 
                                                      Word.WordLsr_class 
                                                      Word.bitSequence
  val instance_Word_WordNot_Num_int32_dict : Word.WordNot_class Num.int32
  val instance_Word_WordNot_Num_int64_dict : Word.WordNot_class Num.int64
  val instance_Word_WordNot_Num_int_dict : Word.WordNot_class Num.int
  val instance_Word_WordNot_Num_integer_dict : Word.WordNot_class Num.integer
  val instance_Word_WordNot_Word_bitSequence_dict : 
                                                      Word.WordNot_class 
                                                      Word.bitSequence
  val instance_Word_WordOr_Num_int32_dict : Word.WordOr_class Num.int32
  val instance_Word_WordOr_Num_int64_dict : Word.WordOr_class Num.int64
  val instance_Word_WordOr_Num_int_dict : Word.WordOr_class Num.int
  val instance_Word_WordOr_Num_integer_dict : Word.WordOr_class Num.integer
  val instance_Word_WordOr_Num_natural_dict : Word.WordOr_class Num.natural
  val instance_Word_WordOr_Word_bitSequence_dict : 
                                                     Word.WordOr_class 
                                                     Word.bitSequence
  val instance_Word_WordOr_nat_dict : Word.WordOr_class nat
  val instance_Word_WordXor_Num_int32_dict : Word.WordXor_class Num.int32
  val instance_Word_WordXor_Num_int64_dict : Word.WordXor_class Num.int64
  val instance_Word_WordXor_Num_int_dict : Word.WordXor_class Num.int
  val instance_Word_WordXor_Num_integer_dict : Word.WordXor_class Num.integer
  val instance_Word_WordXor_Num_natural_dict : Word.WordXor_class Num.natural
  val instance_Word_WordXor_Word_bitSequence_dict : 
                                                      Word.WordXor_class 
                                                      Word.bitSequence
  val instance_Word_WordXor_nat_dict : Word.WordXor_class nat
  val int32Abs : Num.int32 -> Num.int32
  val int32Add : Num.int32 -> Num.int32 -> Num.int32
  val int32Asr : Num.int32 -> nat -> Num.int32
  val int32Compare : Num.int32 -> Num.int32 -> Basic_classes.ordering
  val int32Div : Num.int32 -> Num.int32 -> Num.int32
  val int32Eq : Num.int32 -> Num.int32 -> bool
  val int32FromInt : Num.int -> Num.int32
  val int32FromInt64 : Num.int64 -> Num.int32
  val int32FromInteger : Num.integer -> Num.int32
  val int32FromNat : nat -> Num.int32
  val int32FromNatural : Num.natural -> Num.int32
  val int32FromNumeral : numeral -> Num.int32
  val int32Greater : Num.int32 -> Num.int32 -> bool
  val int32GreaterEqual : Num.int32 -> Num.int32 -> bool
  val int32Land : Num.int32 -> Num.int32 -> Num.int32
  val int32Less : Num.int32 -> Num.int32 -> bool
  val int32LessEqual : Num.int32 -> Num.int32 -> bool
  val int32Lnot : Num.int32 -> Num.int32
  val int32Lor : Num.int32 -> Num.int32 -> Num.int32
  val int32Lsl : Num.int32 -> nat -> Num.int32
  val int32Lsr : Num.int32 -> nat -> Num.int32
  val int32Lxor : Num.int32 -> Num.int32 -> Num.int32
  val int32Max : Num.int32 -> Num.int32 -> Num.int32
  val int32Min : Num.int32 -> Num.int32 -> Num.int32
  val int32Minus : Num.int32 -> Num.int32 -> Num.int32
  val int32Mod : Num.int32 -> Num.int32 -> Num.int32
  val int32Mult : Num.int32 -> Num.int32 -> Num.int32
  val int32Negate : Num.int32 -> Num.int32
  val int32Pow : Num.int32 -> nat -> Num.int32
  val int32Pred : Num.int32 -> Num.int32
  val int32Succ : Num.int32 -> Num.int32
  val int64Abs : Num.int64 -> Num.int64
  val int64Add : Num.int64 -> Num.int64 -> Num.int64
  val int64Asr : Num.int64 -> nat -> Num.int64
  val int64Compare : Num.int64 -> Num.int64 -> Basic_classes.ordering
  val int64Div : Num.int64 -> Num.int64 -> Num.int64
  val int64Eq : Num.int64 -> Num.int64 -> bool
  val int64FromInt : Num.int -> Num.int64
  val int64FromInt32 : Num.int32 -> Num.int64
  val int64FromInteger : Num.integer -> Num.int64
  val int64FromNat : nat -> Num.int64
  val int64FromNatural : Num.natural -> Num.int64
  val int64FromNumeral : numeral -> Num.int64
  val int64Greater : Num.int64 -> Num.int64 -> bool
  val int64GreaterEqual : Num.int64 -> Num.int64 -> bool
  val int64Land : Num.int64 -> Num.int64 -> Num.int64
  val int64Less : Num.int64 -> Num.int64 -> bool
  val int64LessEqual : Num.int64 -> Num.int64 -> bool
  val int64Lnot : Num.int64 -> Num.int64
  val int64Lor : Num.int64 -> Num.int64 -> Num.int64
  val int64Lsl : Num.int64 -> nat -> Num.int64
  val int64Lsr : Num.int64 -> nat -> Num.int64
  val int64Lxor : Num.int64 -> Num.int64 -> Num.int64
  val int64Max : Num.int64 -> Num.int64 -> Num.int64
  val int64Min : Num.int64 -> Num.int64 -> Num.int64
  val int64Minus : Num.int64 -> Num.int64 -> Num.int64
  val int64Mod : Num.int64 -> Num.int64 -> Num.int64
  val int64Mult : Num.int64 -> Num.int64 -> Num.int64
  val int64Negate : Num.int64 -> Num.int64
  val int64Pow : Num.int64 -> nat -> Num.int64
  val int64Pred : Num.int64 -> Num.int64
  val int64Succ : Num.int64 -> Num.int64
  val intAbs : Num.int -> Num.int
  val intAdd : Num.int -> Num.int -> Num.int
  val intAsr : Num.int -> nat -> Num.int
  val intCompare : Num.int -> Num.int -> Basic_classes.ordering
  val intDiv : Num.int -> Num.int -> Num.int
  val intEq : Num.int -> Num.int -> bool
  val intFromBitSeq : Word.bitSequence -> Num.int
  val intFromInt32 : Num.int32 -> Num.int
  val intFromInt64 : Num.int64 -> Num.int
  val intFromInteger : Num.integer -> Num.int
  val intFromNat : nat -> Num.int
  val intFromNatural : Num.natural -> Num.int
  val intFromNumeral : numeral -> Num.int
  val intGreater : Num.int -> Num.int -> bool
  val intGreaterEqual : Num.int -> Num.int -> bool
  val intLand : Num.int -> Num.int -> Num.int
  val intLess : Num.int -> Num.int -> bool
  val intLessEqual : Num.int -> Num.int -> bool
  val intLnot : Num.int -> Num.int
  val intLor : Num.int -> Num.int -> Num.int
  val intLsl : Num.int -> nat -> Num.int
  val intLxor : Num.int -> Num.int -> Num.int
  val intMax : Num.int -> Num.int -> Num.int
  val intMin : Num.int -> Num.int -> Num.int
  val intMinus : Num.int -> Num.int -> Num.int
  val intMod : Num.int -> Num.int -> Num.int
  val intMult : Num.int -> Num.int -> Num.int
  val intNegate : Num.int -> Num.int
  val intPow : Num.int -> nat -> Num.int
  val intPred : Num.int -> Num.int
  val intSucc : Num.int -> Num.int
  val integerAbs : Num.integer -> Num.integer
  val integerAdd : Num.integer -> Num.integer -> Num.integer
  val integerAsr : Num.integer -> nat -> Num.integer
  val integerCompare : Num.integer -> Num.integer -> Basic_classes.ordering
  val integerDiv : Num.integer -> Num.integer -> Num.integer
  val integerEq : Num.integer -> Num.integer -> bool
  val integerFromBitSeq : Word.bitSequence -> Num.integer
  val integerFromBoolList : (bool * (list bool)) -> Num.integer
  val integerFromBoolListAux : Num.integer -> (list bool) -> Num.integer
  val integerFromInt : Num.int -> Num.integer
  val integerFromInt32 : Num.int32 -> Num.integer
  val integerFromInt64 : Num.int64 -> Num.integer
  val integerFromNat : nat -> Num.integer
  val integerFromNatural : Num.natural -> Num.integer
  val integerFromNumeral : numeral -> Num.integer
  val integerGreater : Num.integer -> Num.integer -> bool
  val integerGreaterEqual : Num.integer -> Num.integer -> bool
  val integerLand : Num.integer -> Num.integer -> Num.integer
  val integerLess : Num.integer -> Num.integer -> bool
  val integerLessEqual : Num.integer -> Num.integer -> bool
  val integerLnot : Num.integer -> Num.integer
  val integerLor : Num.integer -> Num.integer -> Num.integer
  val integerLsl : Num.integer -> nat -> Num.integer
  val integerLxor : Num.integer -> Num.integer -> Num.integer
  val integerMax : Num.integer -> Num.integer -> Num.integer
  val integerMin : Num.integer -> Num.integer -> Num.integer
  val integerMinus : Num.integer -> Num.integer -> Num.integer
  val integerMod : Num.integer -> Num.integer -> Num.integer
  val integerMult : Num.integer -> Num.integer -> Num.integer
  val integerNegate : Num.integer -> Num.integer
  val integerPow : Num.integer -> nat -> Num.integer
  val integerPred : Num.integer -> Num.integer
  val integerSucc : Num.integer -> Num.integer
  val inter : forall 'a. 
                (Basic_classes.SetType 'a) => (set 'a) -> (set 'a) -> set 'a
  val intersection : forall 'a. 
                       (Basic_classes.SetType 'a) => 
                         (set 'a) -> (set 'a) -> set 'a
  val intersectionBy : forall 'a. 
                         ('a -> 'a -> Basic_classes.ordering) -> (set 'a) -> 
                                                                 (set 'a) -> 
                                                                 set 
                                                                 'a
  val isEqual : forall 'a. (Basic_classes.Eq 'a) => 'a -> 'a -> bool
  val isGreater : forall 'a. (Basic_classes.Ord 'a) => 'a -> 'a -> bool
  val isGreaterEqual : forall 'a. (Basic_classes.Ord 'a) => 'a -> 'a -> bool
  val isInequal : forall 'a. (Basic_classes.Eq 'a) => 'a -> 'a -> bool
  val isJust : forall 'a. (Maybe.maybe 'a) -> bool
  val isLeft : forall 'a 'b. (Either.either 'a 'b) -> bool
  val isLess : forall 'a. (Basic_classes.Ord 'a) => 'a -> 'a -> bool
  val isLessEqual : forall 'a. (Basic_classes.Ord 'a) => 'a -> 'a -> bool
  val isNothing : forall 'a. (Maybe.maybe 'a) -> bool
  val isProperSubsetOf : forall 'a. 
                           (Basic_classes.SetType 'a) => 
                             (set 'a) -> (set 'a) -> bool
  val isProperSubsetOfBy : forall 'a. 
                             ('a -> 'a -> Basic_classes.ordering) -> 
                             (set 'a) -> (set 'a) -> bool
  val isRight : forall 'a 'b. (Either.either 'a 'b) -> bool
  val isSubsetOf : forall 'a. 
                     (Basic_classes.SetType 'a) => 
                       (set 'a) -> (set 'a) -> bool
  val isSubsetOfBy : forall 'a. 
                       ('a -> 'a -> Basic_classes.ordering) -> (set 'a) -> 
                                                               (set 'a) -> 
                                                               bool
  val land : forall 'a. (Word.WordAnd 'a) => 'a -> 'a -> 'a
  val leastFixedPoint : forall 'a. 
                          (Basic_classes.SetType 'a) => 
                            nat -> ((set 'a) -> set 'a) -> (set 'a) -> set 'a
  val left_shift : forall 'a. (Word.WordLsl 'a) => 'a -> nat -> 'a
  val lefts : forall 'a 'b. (list (Either.either 'a 'b)) -> list 'a
  val length : forall 'a. (list 'a) -> nat
  val lexicographicCompare : forall 'a. 
                               (Basic_classes.Ord 'a) => 
                                 (list 'a) -> (list 'a) -> Basic_classes.ordering
  val lexicographicCompareBy : forall 'a. 
                                 ('a -> 'a -> Basic_classes.ordering) -> 
                                 (list 'a) -> (list 'a) -> Basic_classes.ordering
  val lexicographicLess : forall 'a. 
                            (Basic_classes.Ord 'a) => 
                              (list 'a) -> (list 'a) -> bool
  val lexicographicLessBy : forall 'a. 
                              ('a -> 'a -> bool) -> ('a -> 'a -> bool) -> 
                                                    (list 'a) -> (list 'a) -> 
                                                                 bool
  val lexicographicLessEq : forall 'a. 
                              (Basic_classes.Ord 'a) => 
                                (list 'a) -> (list 'a) -> bool
  val lexicographicLessEqBy : forall 'a. 
                                ('a -> 'a -> bool) -> ('a -> 'a -> bool) -> 
                                                      (list 'a) -> (list 'a) -> 
                                                                   bool
  val listEqual : forall 'a. 
                    (Basic_classes.Eq 'a) => (list 'a) -> (list 'a) -> bool
  val listEqualBy : forall 'a. 
                      ('a -> 'a -> bool) -> (list 'a) -> (list 'a) -> bool
  val lnot : forall 'a. (Word.WordNot 'a) => 'a -> 'a
  val logicial_right_shift : forall 'a. (Word.WordLsr 'a) => 'a -> nat -> 'a
  val lookup : forall 'a 'b. 
                 (Basic_classes.Eq 'a) => 
                   'a -> (list ('a * 'b)) -> Maybe.maybe 'b
  val lookupBy : forall 'a 'b. 
                   ('a -> 'a -> bool) -> 'a -> (list ('a * 'b)) -> Maybe.maybe 
                                                                   'b
  val lor : forall 'a. (Word.WordOr 'a) => 'a -> 'a -> 'a
  val lsl : forall 'a. (Word.WordLsl 'a) => 'a -> nat -> 'a
  val lsr : forall 'a. (Word.WordLsr 'a) => 'a -> nat -> 'a
  val lxor : forall 'a. (Word.WordXor 'a) => 'a -> 'a -> 'a
  val makeString : nat -> char -> string
  val map : forall 'a 'b. ('a -> 'b) -> (list 'a) -> list 'b
  val mapBy : forall 'a 'b. 
                ('b -> 'b -> Basic_classes.ordering) -> ('a -> 'b) -> 
                                                        (set 'a) -> set 'b
  val mapEqual : forall 'k 'v. 
                   (Basic_classes.Eq 'k) (Basic_classes.Eq 'v) => 
                     (Map.map 'k 'v) -> (Map.map 'k 'v) -> bool
  val mapEqualBy : forall 'k 'v. 
                     ('k -> 'k -> bool) -> ('v -> 'v -> bool) -> (Map.map 
                                                                 'k 'v) -> 
                                                                 (Map.map 
                                                                 'k 'v) -> 
                                                                 bool
  val mapKeyCompare : forall 'a. 
                        (Map.MapKeyType 'a) => 
                          'a -> 'a -> Basic_classes.ordering
  val max : forall 'a. (Basic_classes.OrdMaxMin 'a) => 'a -> 'a -> 'a
  val maxByLessEqual : forall 'a. ('a -> 'a -> bool) -> 'a -> 'a -> 'a
  val maybe : forall 'a 'b. 'b -> ('a -> 'b) -> (Maybe.maybe 'a) -> 'b
  val maybeCompare : forall 'a 'b. 
                       ('b -> 'a -> Basic_classes.ordering) -> (Maybe.maybe 
                                                               'b) -> 
                                                               (Maybe.maybe 
                                                               'a) -> 
                                                               Basic_classes.ordering
  val maybeEqual : forall 'a. 
                     (Basic_classes.Eq 'a) => 
                       (Maybe.maybe 'a) -> (Maybe.maybe 'a) -> bool
  val maybeEqualBy : forall 'a. 
                       ('a -> 'a -> bool) -> (Maybe.maybe 'a) -> (Maybe.maybe 
                                                                 'a) -> 
                                                                 bool
  val member : forall 'a. 
                 (Basic_classes.SetType 'a) => 'a -> (set 'a) -> bool
  val memberBy : forall 'a. 
                   ('a -> 'a -> Basic_classes.ordering) -> 'a -> (set 'a) -> 
                                                                 bool
  val min : forall 'a. (Basic_classes.OrdMaxMin 'a) => 'a -> 'a -> 'a
  val minByLessEqual : forall 'a. ('a -> 'a -> bool) -> 'a -> 'a -> 'a
  val mod : forall 'a. (Num.NumRemainder 'a) => 'a -> 'a -> 'a
  val natAdd : nat -> nat -> nat
  val natAsr : nat -> nat -> nat
  val natCompare : nat -> nat -> Basic_classes.ordering
  val natDiv : nat -> nat -> nat
  val natEq : nat -> nat -> bool
  val natFromBitSeq : Word.bitSequence -> nat
  val natFromInt : Num.int -> nat
  val natFromInt32 : Num.int32 -> nat
  val natFromInt64 : Num.int64 -> nat
  val natFromInteger : Num.integer -> nat
  val natFromNatural : Num.natural -> nat
  val natFromNumeral : numeral -> nat
  val natGreater : nat -> nat -> bool
  val natGreaterEqual : nat -> nat -> bool
  val natLand : nat -> nat -> nat
  val natLess : nat -> nat -> bool
  val natLessEqual : nat -> nat -> bool
  val natLor : nat -> nat -> nat
  val natLsl : nat -> nat -> nat
  val natLxor : nat -> nat -> nat
  val natMax : nat -> nat -> nat
  val natMin : nat -> nat -> nat
  val natMinus : nat -> nat -> nat
  val natMod : nat -> nat -> nat
  val natMult : nat -> nat -> nat
  val natPow : nat -> nat -> nat
  val natPred : nat -> nat
  val natSucc : nat -> nat
  val naturalAdd : Num.natural -> Num.natural -> Num.natural
  val naturalAsr : Num.natural -> nat -> Num.natural
  val naturalCompare : Num.natural -> Num.natural -> Basic_classes.ordering
  val naturalDiv : Num.natural -> Num.natural -> Num.natural
  val naturalEq : Num.natural -> Num.natural -> bool
  val naturalFromBitSeq : Word.bitSequence -> Num.natural
  val naturalFromInt : Num.int -> Num.natural
  val naturalFromInt32 : Num.int32 -> Num.natural
  val naturalFromInt64 : Num.int64 -> Num.natural
  val naturalFromInteger : Num.integer -> Num.natural
  val naturalFromNat : nat -> Num.natural
  val naturalFromNumeral : numeral -> Num.natural
  val naturalGreater : Num.natural -> Num.natural -> bool
  val naturalGreaterEqual : Num.natural -> Num.natural -> bool
  val naturalLand : Num.natural -> Num.natural -> Num.natural
  val naturalLess : Num.natural -> Num.natural -> bool
  val naturalLessEqual : Num.natural -> Num.natural -> bool
  val naturalLor : Num.natural -> Num.natural -> Num.natural
  val naturalLsl : Num.natural -> nat -> Num.natural
  val naturalLxor : Num.natural -> Num.natural -> Num.natural
  val naturalMax : Num.natural -> Num.natural -> Num.natural
  val naturalMin : Num.natural -> Num.natural -> Num.natural
  val naturalMinus : Num.natural -> Num.natural -> Num.natural
  val naturalMod : Num.natural -> Num.natural -> Num.natural
  val naturalMult : Num.natural -> Num.natural -> Num.natural
  val naturalPow : Num.natural -> nat -> Num.natural
  val naturalPred : Num.natural -> Num.natural
  val naturalSucc : Num.natural -> Num.natural
  val not : bool -> bool
  val notMember : forall 'a. 
                    (Basic_classes.SetType 'a) => 'a -> (set 'a) -> bool
  val null : forall 'a. (list 'a) -> bool
  val numAdd : forall 'a. (Num.NumAdd 'a) => 'a -> 'a -> 'a
  val numDivision : forall 'a. (Num.NumDivision 'a) => 'a -> 'a -> 'a
  val numIntegerDivision : forall 'a. 
                             (Num.NumIntegerDivision 'a) => 'a -> 'a -> 'a
  val numMinus : forall 'a. (Num.NumMinus 'a) => 'a -> 'a -> 'a
  val numMult : forall 'a. (Num.NumMult 'a) => 'a -> 'a -> 'a
  val numNegate : forall 'a. (Num.NumNegate 'a) => 'a -> 'a
  val numPow : forall 'a. (Num.NumPow 'a) => 'a -> nat -> 'a
  val numRemainder : forall 'a. (Num.NumRemainder 'a) => 'a -> 'a -> 'a
  val or : bool -> bool -> bool
  val ordCompare : forall 'a. 
                     (Basic_classes.Eq 'a) (Basic_classes.Ord 'a) => 
                       'a -> 'a -> Basic_classes.ordering
  val orderingEqual : 
                        Basic_classes.ordering -> Basic_classes.ordering -> 
                                                  bool
  val orderingIsEqual : Basic_classes.ordering -> bool
  val orderingIsGreater : Basic_classes.ordering -> bool
  val orderingIsGreaterEqual : Basic_classes.ordering -> bool
  val orderingIsLess : Basic_classes.ordering -> bool
  val orderingIsLessEqual : Basic_classes.ordering -> bool
  val ordering_cases : forall 'a. 
                         Basic_classes.ordering -> 'a -> 'a -> 'a -> 'a
  val pairCompare : forall 'a 'b. 
                      ('a -> 'a -> Basic_classes.ordering) -> ('b -> 
                                                              'b -> Basic_classes.ordering) -> 
                                                              ('a * 'b) -> 
                                                              ('a * 'b) -> 
                                                              Basic_classes.ordering
  val pairEqual : forall 'a 'b. 
                    (Basic_classes.Eq 'a) (Basic_classes.Eq 'b) => 
                      ('a * 'b) -> ('a * 'b) -> bool
  val pairEqualBy : forall 'a 'b. 
                      ('a -> 'a -> bool) -> ('b -> 'b -> bool) -> ('a * 'b) -> 
                                                                  ('a * 'b) -> 
                                                                  bool
  val pairGreater : forall 'a 'b. 
                      (Basic_classes.Ord 'a) (Basic_classes.Ord 'b) => 
                        ('a * 'b) -> ('a * 'b) -> bool
  val pairGreaterEq : forall 'a 'b. 
                        (Basic_classes.Ord 'a) (Basic_classes.Ord 'b) => 
                          ('a * 'b) -> ('a * 'b) -> bool
  val pairLess : forall 'a 'b. 
                   (Basic_classes.Ord 'a) (Basic_classes.Ord 'b) => 
                     ('b * 'a) -> ('b * 'a) -> bool
  val pairLessEq : forall 'a 'b. 
                     (Basic_classes.Ord 'a) (Basic_classes.Ord 'b) => 
                       ('b * 'a) -> ('b * 'a) -> bool
  val partition : forall 'a. 
                    ('a -> bool) -> (list 'a) -> ((list 'a) * (list 'a))
  val partitionEither : forall 'a 'b. 
                          (list (Either.either 'a 'b)) -> ((list 'a) *
                                                           (list 'b))
  val pred : forall 'a. (Num.NumPred 'a) => 'a -> 'a
  val range : forall 'k 'v. 
                (Map.MapKeyType 'k) (Basic_classes.SetType 'v) => 
                  (Map.map 'k 'v) -> set 'v
  val rangeBy : forall 'k 'v. 
                  ('v -> 'v -> Basic_classes.ordering) -> (Map.map 'k 'v) -> 
                                                          set 'v
  val replicate : forall 'a. nat -> 'a -> list 'a
  val resizeBitSeq : 
                       (Maybe.maybe nat) -> Word.bitSequence -> Word.bitSequence
  val reverse : forall 'a. (list 'a) -> list 'a
  val reverseAppend : forall 'a. (list 'a) -> (list 'a) -> list 'a
  val reverseMap : forall 'a 'b. ('a -> 'b) -> (list 'a) -> list 'b
  val reversePartition : forall 'a. 
                           ('a -> bool) -> (list 'a) -> ((list 'a) *
                                                         (list 'a))
  val rights : forall 'a 'b. (list (Either.either 'a 'b)) -> list 'b
  val setCompare : forall 'a. 
                     (Basic_classes.SetType 'a) => 
                       (set 'a) -> (set 'a) -> Basic_classes.ordering
  val setCompareBy : forall 'a. 
                       ('a -> 'a -> Basic_classes.ordering) -> (set 'a) -> 
                                                               (set 'a) -> 
                                                               Basic_classes.ordering
  val setElemCompare : forall 'a. 
                         (Basic_classes.SetType 'a) => 
                           'a -> 'a -> Basic_classes.ordering
  val setEqual : forall 'a. 
                   (Basic_classes.SetType 'a) => (set 'a) -> (set 'a) -> bool
  val setEqualBy : forall 'a. 
                     ('a -> 'a -> Basic_classes.ordering) -> (set 'a) -> 
                                                             (set 'a) -> 
                                                             bool
  val set_case : forall 'a 'b. 
                   (Basic_classes.SetType 'a) => 
                     (set 'a) -> 'b -> ('a -> 'b) -> 'b -> 'b
  val sigma : forall 'a 'b. 
                (Basic_classes.SetType 'a) (Basic_classes.SetType 'b) => 
                  (set 'a) -> ('a -> set 'b) -> set ('a * 'b)
  val sigmaBy : forall 'a 'b. 
                  (('a * 'b) -> ('a * 'b) -> Basic_classes.ordering) -> 
                  (set 'a) -> ('a -> set 'b) -> set ('a * 'b)
  val singleton : forall 'a. (Basic_classes.SetType 'a) => 'a -> set 'a
  val size : forall 'a. (Basic_classes.SetType 'a) => (set 'a) -> nat
  val snd : forall 'a 'b. ('a * 'b) -> 'b
  val snoc : forall 'a. 'a -> (list 'a) -> list 'a
  val split : forall 'a. 
                (Basic_classes.SetType 'a) (Basic_classes.Ord 'a) => 
                  'a -> (set 'a) -> ((set 'a) * (set 'a))
  val splitAt : forall 'a. nat -> (list 'a) -> ((list 'a) * (list 'a))
  val splitMember : forall 'a. 
                      (Basic_classes.SetType 'a) (Basic_classes.Ord 'a) => 
                        'a -> (set 'a) -> ((set 'a) * bool * (set 'a))
  val stringAppend : string -> string -> string
  val stringLength : string -> nat
  val string_case : forall 'a. string -> 'a -> (char -> string -> 'a) -> 'a
  val string_of_natural : Num.natural -> string
  val subset : forall 'a. 
                 (Basic_classes.SetType 'a) => (set 'a) -> (set 'a) -> bool
  val succ : forall 'a. (Num.NumSucc 'a) => 'a -> 'a
  val swap : forall 'a 'b. ('a * 'b) -> ('b * 'a)
  val take : forall 'a. nat -> (list 'a) -> list 'a
  val takeWhile : forall 'a. ('a -> bool) -> (list 'a) -> list 'a
  val toCharList : string -> list char
  val toSet : forall 'k 'v. 
                (Map.MapKeyType 'k) (Basic_classes.SetType 'k)
                  (Basic_classes.SetType 'v) => 
                  (Map.map 'k 'v) -> set ('k * 'v)
  val toSetBy : forall 'k 'v. 
                  (('k * 'v) -> ('k * 'v) -> Basic_classes.ordering) -> 
                  (Map.map 'k 'v) -> set ('k * 'v)
  val toString : (list char) -> string
  val tripleCompare : forall 'a 'b 'c. 
                        ('a -> 'a -> Basic_classes.ordering) -> ('b -> 
                                                                'b -> 
                                                                Basic_classes.ordering) -> 
                                                                ('c -> 
                                                                'c -> 
                                                                Basic_classes.ordering) -> 
                                                                ('a * 'b * 'c) -> 
                                                                ('a * 'b * 'c) -> 
                                                                Basic_classes.ordering
  val tripleEqual : forall 'a 'b 'c. 
                      (Basic_classes.Eq 'a) (Basic_classes.Eq 'b)
                        (Basic_classes.Eq 'c) => 
                        ('a * 'b * 'c) -> ('a * 'b * 'c) -> bool
  val tripleGreater : forall 'a 'b 'c. 
                        (Basic_classes.Ord 'a) (Basic_classes.Ord 'b)
                          (Basic_classes.Ord 'c) => 
                          ('c * 'b * 'a) -> ('c * 'b * 'a) -> bool
  val tripleGreaterEq : forall 'a 'b 'c. 
                          (Basic_classes.Ord 'a) (Basic_classes.Ord 'b)
                            (Basic_classes.Ord 'c) => 
                            ('c * 'b * 'a) -> ('c * 'b * 'a) -> bool
  val tripleLess : forall 'a 'b 'c. 
                     (Basic_classes.Ord 'a) (Basic_classes.Ord 'b)
                       (Basic_classes.Ord 'c) => 
                       ('a * 'b * 'c) -> ('a * 'b * 'c) -> bool
  val tripleLessEq : forall 'a 'b 'c. 
                       (Basic_classes.Ord 'a) (Basic_classes.Ord 'b)
                         (Basic_classes.Ord 'c) => 
                         ('a * 'b * 'c) -> ('a * 'b * 'c) -> bool
  val uncurry : forall 'a 'b 'c. ('a -> 'b -> 'c) -> ('a * 'b) -> 'c
  val union : forall 'a. 
                (Basic_classes.SetType 'a) => (set 'a) -> (set 'a) -> set 'a
  val unionBy : forall 'a. 
                  ('a -> 'a -> Basic_classes.ordering) -> (set 'a) -> 
                                                          (set 'a) -> 
                                                          set 'a
  val unions : forall 'k 'v. 
                 (Map.MapKeyType 'k) => 
                   (list (Map.map 'k 'v)) -> Map.map 'k 'v
  val unsafe_structural_equality : forall 'a. 'a -> 'a -> bool
  val unsafe_structural_inequality : forall 'a. 'a -> 'a -> bool
  val unzip : forall 'a 'b. (list ('a * 'b)) -> ((list 'a) * (list 'b))
  val update : forall 'a. (list 'a) -> nat -> 'a -> list 'a
  val xor : bool -> bool -> bool
  val zip : forall 'a 'b. (list 'a) -> (list 'b) -> list ('a * 'b)
  val || : bool -> bool -> bool
  val ~ : forall 'a. (Num.NumNegate 'a) => 'a -> 'a

  module Instance_Basic_classes_Eq_Basic_classes_ordering = struct

    val <> : Basic_classes.ordering -> Basic_classes.ordering -> bool
    val = : Basic_classes.ordering -> Basic_classes.ordering -> bool

  end

  module Instance_Basic_classes_Eq_Either_either = struct

    val <> : forall 'a 'b. 
               (Basic_classes.Eq 'a) (Basic_classes.Eq 'b) => 
                 (Either.either 'a 'b) -> (Either.either 'a 'b) -> bool
    val = : forall 'a 'b. 
              (Basic_classes.Eq 'a) (Basic_classes.Eq 'b) => 
                (Either.either 'a 'b) -> (Either.either 'a 'b) -> bool

  end

  module Instance_Basic_classes_Eq_Map_map = struct

    val <> : forall 'k 'v. 
               (Basic_classes.Eq 'k) (Basic_classes.Eq 'v) => 
                 (Map.map 'k 'v) -> (Map.map 'k 'v) -> bool
    val = : forall 'k 'v. 
              (Basic_classes.Eq 'k) (Basic_classes.Eq 'v) => 
                (Map.map 'k 'v) -> (Map.map 'k 'v) -> bool

  end

  module Instance_Basic_classes_Eq_Maybe_maybe = struct

    val <> : forall 'a. 
               (Basic_classes.Eq 'a) => 
                 (Maybe.maybe 'a) -> (Maybe.maybe 'a) -> bool
    val = : forall 'a. 
              (Basic_classes.Eq 'a) => 
                (Maybe.maybe 'a) -> (Maybe.maybe 'a) -> bool

  end

  module Instance_Basic_classes_Eq_Num_int = struct

    val <> : Num.int -> Num.int -> bool
    val = : Num.int -> Num.int -> bool

  end

  module Instance_Basic_classes_Eq_Num_int32 = struct

    val <> : Num.int32 -> Num.int32 -> bool
    val = : Num.int32 -> Num.int32 -> bool

  end

  module Instance_Basic_classes_Eq_Num_int64 = struct

    val <> : Num.int64 -> Num.int64 -> bool
    val = : Num.int64 -> Num.int64 -> bool

  end

  module Instance_Basic_classes_Eq_Num_integer = struct

    val <> : Num.integer -> Num.integer -> bool
    val = : Num.integer -> Num.integer -> bool

  end

  module Instance_Basic_classes_Eq_Num_natural = struct

    val <> : Num.natural -> Num.natural -> bool
    val = : Num.natural -> Num.natural -> bool

  end

  module Instance_Basic_classes_Eq_Word_bitSequence = struct

    val <> : Word.bitSequence -> Word.bitSequence -> bool
    val = : Word.bitSequence -> Word.bitSequence -> bool

  end

  module Instance_Basic_classes_Eq_bool = struct

    val <> : bool -> bool -> bool
    val = : bool -> bool -> bool

  end

  module Instance_Basic_classes_Eq_list = struct

    val <> : forall 'a. 
               (Basic_classes.Eq 'a) => (list 'a) -> (list 'a) -> bool
    val = : forall 'a. 
              (Basic_classes.Eq 'a) => (list 'a) -> (list 'a) -> bool

  end

  module Instance_Basic_classes_Eq_nat = struct

    val <> : nat -> nat -> bool
    val = : nat -> nat -> bool

  end

  module Instance_Basic_classes_Eq_set = struct

    val <> : forall 'a. 
               (Basic_classes.SetType 'a) => (set 'a) -> (set 'a) -> bool
    val = : forall 'a. 
              (Basic_classes.SetType 'a) => (set 'a) -> (set 'a) -> bool

  end

  module Instance_Basic_classes_Eq_tup2 = struct

    val <> : forall 'a 'b. 
               (Basic_classes.Eq 'a) (Basic_classes.Eq 'b) => 
                 ('a * 'b) -> ('a * 'b) -> bool
    val = : forall 'a 'b. 
              (Basic_classes.Eq 'a) (Basic_classes.Eq 'b) => 
                ('a * 'b) -> ('a * 'b) -> bool

  end

  module Instance_Basic_classes_Eq_tup3 = struct

    val <> : forall 'a 'b 'c. 
               (Basic_classes.Eq 'a) (Basic_classes.Eq 'b)
                 (Basic_classes.Eq 'c) => 
                 ('a * 'b * 'c) -> ('a * 'b * 'c) -> bool
    val = : forall 'a 'b 'c. 
              (Basic_classes.Eq 'a) (Basic_classes.Eq 'b)
                (Basic_classes.Eq 'c) => 
                ('a * 'b * 'c) -> ('a * 'b * 'c) -> bool

  end

  module Instance_Basic_classes_Eq_var = struct

    val <> : forall 'a. 'a -> 'a -> bool
    val = : forall 'a. 'a -> 'a -> bool

  end

  module Instance_Basic_classes_OrdMaxMin_Num_int = struct

    val max : Num.int -> Num.int -> Num.int
    val min : Num.int -> Num.int -> Num.int

  end

  module Instance_Basic_classes_OrdMaxMin_Num_int32 = struct

    val max : Num.int32 -> Num.int32 -> Num.int32
    val min : Num.int32 -> Num.int32 -> Num.int32

  end

  module Instance_Basic_classes_OrdMaxMin_Num_int64 = struct

    val max : Num.int64 -> Num.int64 -> Num.int64
    val min : Num.int64 -> Num.int64 -> Num.int64

  end

  module Instance_Basic_classes_OrdMaxMin_Num_integer = struct

    val max : Num.integer -> Num.integer -> Num.integer
    val min : Num.integer -> Num.integer -> Num.integer

  end

  module Instance_Basic_classes_OrdMaxMin_Num_natural = struct

    val max : Num.natural -> Num.natural -> Num.natural
    val min : Num.natural -> Num.natural -> Num.natural

  end

  module Instance_Basic_classes_OrdMaxMin_Word_bitSequence = struct

    val max : Word.bitSequence -> Word.bitSequence -> Word.bitSequence
    val min : Word.bitSequence -> Word.bitSequence -> Word.bitSequence

  end

  module Instance_Basic_classes_OrdMaxMin_nat = struct

    val max : nat -> nat -> nat
    val min : nat -> nat -> nat

  end

  module Instance_Basic_classes_OrdMaxMin_var = struct

    val max : forall 'a. (Basic_classes.Ord 'a) => 'a -> 'a -> 'a
    val min : forall 'a. (Basic_classes.Ord 'a) => 'a -> 'a -> 'a

  end

  module Instance_Basic_classes_Ord_Num_int = struct

    val < : Num.int -> Num.int -> bool
    val <= : Num.int -> Num.int -> bool
    val > : Num.int -> Num.int -> bool
    val >= : Num.int -> Num.int -> bool
    val compare : Num.int -> Num.int -> Basic_classes.ordering

  end

  module Instance_Basic_classes_Ord_Num_int32 = struct

    val < : Num.int32 -> Num.int32 -> bool
    val <= : Num.int32 -> Num.int32 -> bool
    val > : Num.int32 -> Num.int32 -> bool
    val >= : Num.int32 -> Num.int32 -> bool
    val compare : Num.int32 -> Num.int32 -> Basic_classes.ordering

  end

  module Instance_Basic_classes_Ord_Num_int64 = struct

    val < : Num.int64 -> Num.int64 -> bool
    val <= : Num.int64 -> Num.int64 -> bool
    val > : Num.int64 -> Num.int64 -> bool
    val >= : Num.int64 -> Num.int64 -> bool
    val compare : Num.int64 -> Num.int64 -> Basic_classes.ordering

  end

  module Instance_Basic_classes_Ord_Num_integer = struct

    val < : Num.integer -> Num.integer -> bool
    val <= : Num.integer -> Num.integer -> bool
    val > : Num.integer -> Num.integer -> bool
    val >= : Num.integer -> Num.integer -> bool
    val compare : Num.integer -> Num.integer -> Basic_classes.ordering

  end

  module Instance_Basic_classes_Ord_Num_natural = struct

    val < : Num.natural -> Num.natural -> bool
    val <= : Num.natural -> Num.natural -> bool
    val > : Num.natural -> Num.natural -> bool
    val >= : Num.natural -> Num.natural -> bool
    val compare : Num.natural -> Num.natural -> Basic_classes.ordering

  end

  module Instance_Basic_classes_Ord_Word_bitSequence = struct

    val < : Word.bitSequence -> Word.bitSequence -> bool
    val <= : Word.bitSequence -> Word.bitSequence -> bool
    val > : Word.bitSequence -> Word.bitSequence -> bool
    val >= : Word.bitSequence -> Word.bitSequence -> bool
    val compare : 
                    Word.bitSequence -> Word.bitSequence -> Basic_classes.ordering

  end

  module Instance_Basic_classes_Ord_list = struct

    val < : forall 'a. 
              (Basic_classes.Ord 'a) => (list 'a) -> (list 'a) -> bool
    val <= : forall 'a. 
               (Basic_classes.Ord 'a) => (list 'a) -> (list 'a) -> bool
    val > : forall 'a. 
              (Basic_classes.Ord 'a) => (list 'a) -> (list 'a) -> bool
    val >= : forall 'a. 
               (Basic_classes.Ord 'a) => (list 'a) -> (list 'a) -> bool
    val compare : forall 'a. 
                    (Basic_classes.Ord 'a) => 
                      (list 'a) -> (list 'a) -> Basic_classes.ordering

  end

  module Instance_Basic_classes_Ord_nat = struct

    val < : nat -> nat -> bool
    val <= : nat -> nat -> bool
    val > : nat -> nat -> bool
    val >= : nat -> nat -> bool
    val compare : nat -> nat -> Basic_classes.ordering

  end

  module Instance_Basic_classes_Ord_tup2 = struct

    val < : forall 'a 'b. 
              (Basic_classes.Ord 'a) (Basic_classes.Ord 'b) => 
                ('a * 'b) -> ('a * 'b) -> bool
    val <= : forall 'a 'b. 
               (Basic_classes.Ord 'a) (Basic_classes.Ord 'b) => 
                 ('a * 'b) -> ('a * 'b) -> bool
    val > : forall 'a 'b. 
              (Basic_classes.Ord 'a) (Basic_classes.Ord 'b) => 
                ('a * 'b) -> ('a * 'b) -> bool
    val >= : forall 'a 'b. 
               (Basic_classes.Ord 'a) (Basic_classes.Ord 'b) => 
                 ('a * 'b) -> ('a * 'b) -> bool
    val compare : forall 'a 'b. 
                    (Basic_classes.Ord 'a) (Basic_classes.Ord 'b) => 
                      ('a * 'b) -> ('a * 'b) -> Basic_classes.ordering

  end

  module Instance_Basic_classes_Ord_tup3 = struct

    val < : forall 'a 'b 'c. 
              (Basic_classes.Ord 'a) (Basic_classes.Ord 'b)
                (Basic_classes.Ord 'c) => 
                ('a * 'b * 'c) -> ('a * 'b * 'c) -> bool
    val <= : forall 'a 'b 'c. 
               (Basic_classes.Ord 'a) (Basic_classes.Ord 'b)
                 (Basic_classes.Ord 'c) => 
                 ('a * 'b * 'c) -> ('a * 'b * 'c) -> bool
    val > : forall 'a 'b 'c. 
              (Basic_classes.Ord 'a) (Basic_classes.Ord 'b)
                (Basic_classes.Ord 'c) => 
                ('a * 'b * 'c) -> ('a * 'b * 'c) -> bool
    val >= : forall 'a 'b 'c. 
               (Basic_classes.Ord 'a) (Basic_classes.Ord 'b)
                 (Basic_classes.Ord 'c) => 
                 ('a * 'b * 'c) -> ('a * 'b * 'c) -> bool
    val compare : forall 'a 'b 'c. 
                    (Basic_classes.Ord 'a) (Basic_classes.Ord 'b)
                      (Basic_classes.Ord 'c) => 
                      ('a * 'b * 'c) -> ('a * 'b * 'c) -> Basic_classes.ordering

  end

  module Instance_Basic_classes_SetType_Maybe_maybe = struct

    val setElemCompare : forall 'a. 
                           (Basic_classes.SetType 'a) => 
                             (Maybe.maybe 'a) -> (Maybe.maybe 'a) -> 
                                                 Basic_classes.ordering

  end

  module Instance_Basic_classes_SetType_Num_int = struct

    val setElemCompare : Num.int -> Num.int -> Basic_classes.ordering

  end

  module Instance_Basic_classes_SetType_Num_int32 = struct

    val setElemCompare : Num.int32 -> Num.int32 -> Basic_classes.ordering

  end

  module Instance_Basic_classes_SetType_Num_int64 = struct

    val setElemCompare : Num.int64 -> Num.int64 -> Basic_classes.ordering

  end

  module Instance_Basic_classes_SetType_Num_integer = struct

    val setElemCompare : Num.integer -> Num.integer -> Basic_classes.ordering

  end

  module Instance_Basic_classes_SetType_Num_natural = struct

    val setElemCompare : Num.natural -> Num.natural -> Basic_classes.ordering

  end

  module Instance_Basic_classes_SetType_Word_bitSequence = struct

    val setElemCompare : 
                           Word.bitSequence -> Word.bitSequence -> Basic_classes.ordering

  end

  module Instance_Basic_classes_SetType_bool = struct

    val setElemCompare : bool -> bool -> Basic_classes.ordering

  end

  module Instance_Basic_classes_SetType_list = struct

    val setElemCompare : forall 'a. 
                           (Basic_classes.SetType 'a) => 
                             (list 'a) -> (list 'a) -> Basic_classes.ordering

  end

  module Instance_Basic_classes_SetType_nat = struct

    val setElemCompare : nat -> nat -> Basic_classes.ordering

  end

  module Instance_Basic_classes_SetType_set = struct

    val setElemCompare : forall 'a. 
                           (Basic_classes.SetType 'a) => 
                             (set 'a) -> (set 'a) -> Basic_classes.ordering

  end

  module Instance_Basic_classes_SetType_tup2 = struct

    val setElemCompare : forall 'a 'b. 
                           (Basic_classes.SetType 'a)
                             (Basic_classes.SetType 'b) => 
                             ('a * 'b) -> ('a * 'b) -> Basic_classes.ordering

  end

  module Instance_Basic_classes_SetType_tup3 = struct

    val setElemCompare : forall 'a 'b 'c. 
                           (Basic_classes.SetType 'a)
                             (Basic_classes.SetType 'b)
                             (Basic_classes.SetType 'c) => 
                             ('a * 'b * 'c) -> ('a * 'b * 'c) -> Basic_classes.ordering

  end

  module Instance_Basic_classes_SetType_var = struct

    val setElemCompare : forall 'a. 'a -> 'a -> Basic_classes.ordering

  end

  module Instance_Map_MapKeyType_var = struct

    val mapKeyCompare : forall 'a. 
                          (Basic_classes.SetType 'a) => 
                            'a -> 'a -> Basic_classes.ordering

  end

  module Instance_Num_NumAbs_Num_int = struct

    val abs : Num.int -> Num.int

  end

  module Instance_Num_NumAbs_Num_int32 = struct

    val abs : Num.int32 -> Num.int32

  end

  module Instance_Num_NumAbs_Num_int64 = struct

    val abs : Num.int64 -> Num.int64

  end

  module Instance_Num_NumAbs_Num_integer = struct

    val abs : Num.integer -> Num.integer

  end

  module Instance_Num_NumAdd_Num_int = struct

    val + : Num.int -> Num.int -> Num.int

  end

  module Instance_Num_NumAdd_Num_int32 = struct

    val + : Num.int32 -> Num.int32 -> Num.int32

  end

  module Instance_Num_NumAdd_Num_int64 = struct

    val + : Num.int64 -> Num.int64 -> Num.int64

  end

  module Instance_Num_NumAdd_Num_integer = struct

    val + : Num.integer -> Num.integer -> Num.integer

  end

  module Instance_Num_NumAdd_Num_natural = struct

    val + : Num.natural -> Num.natural -> Num.natural

  end

  module Instance_Num_NumAdd_Word_bitSequence = struct

    val + : Word.bitSequence -> Word.bitSequence -> Word.bitSequence

  end

  module Instance_Num_NumAdd_nat = struct

    val + : nat -> nat -> nat

  end

  module Instance_Num_NumDivision_Num_int = struct

    val / : Num.int -> Num.int -> Num.int

  end

  module Instance_Num_NumDivision_Num_int32 = struct

    val / : Num.int32 -> Num.int32 -> Num.int32

  end

  module Instance_Num_NumDivision_Num_int64 = struct

    val / : Num.int64 -> Num.int64 -> Num.int64

  end

  module Instance_Num_NumDivision_Num_integer = struct

    val / : Num.integer -> Num.integer -> Num.integer

  end

  module Instance_Num_NumDivision_Num_natural = struct

    val / : Num.natural -> Num.natural -> Num.natural

  end

  module Instance_Num_NumDivision_Word_bitSequence = struct

    val / : Word.bitSequence -> Word.bitSequence -> Word.bitSequence

  end

  module Instance_Num_NumDivision_nat = struct

    val / : nat -> nat -> nat

  end

  module Instance_Num_NumIntegerDivision_Num_int = struct

    val div : Num.int -> Num.int -> Num.int

  end

  module Instance_Num_NumIntegerDivision_Num_int32 = struct

    val div : Num.int32 -> Num.int32 -> Num.int32

  end

  module Instance_Num_NumIntegerDivision_Num_int64 = struct

    val div : Num.int64 -> Num.int64 -> Num.int64

  end

  module Instance_Num_NumIntegerDivision_Num_integer = struct

    val div : Num.integer -> Num.integer -> Num.integer

  end

  module Instance_Num_NumIntegerDivision_Num_natural = struct

    val div : Num.natural -> Num.natural -> Num.natural

  end

  module Instance_Num_NumIntegerDivision_Word_bitSequence = struct

    val div : Word.bitSequence -> Word.bitSequence -> Word.bitSequence

  end

  module Instance_Num_NumIntegerDivision_nat = struct

    val div : nat -> nat -> nat

  end

  module Instance_Num_NumMinus_Num_int = struct

    val - : Num.int -> Num.int -> Num.int

  end

  module Instance_Num_NumMinus_Num_int32 = struct

    val - : Num.int32 -> Num.int32 -> Num.int32

  end

  module Instance_Num_NumMinus_Num_int64 = struct

    val - : Num.int64 -> Num.int64 -> Num.int64

  end

  module Instance_Num_NumMinus_Num_integer = struct

    val - : Num.integer -> Num.integer -> Num.integer

  end

  module Instance_Num_NumMinus_Num_natural = struct

    val - : Num.natural -> Num.natural -> Num.natural

  end

  module Instance_Num_NumMinus_Word_bitSequence = struct

    val - : Word.bitSequence -> Word.bitSequence -> Word.bitSequence

  end

  module Instance_Num_NumMinus_nat = struct

    val - : nat -> nat -> nat

  end

  module Instance_Num_NumMult_Num_int = struct

    val * : Num.int -> Num.int -> Num.int

  end

  module Instance_Num_NumMult_Num_int32 = struct

    val * : Num.int32 -> Num.int32 -> Num.int32

  end

  module Instance_Num_NumMult_Num_int64 = struct

    val * : Num.int64 -> Num.int64 -> Num.int64

  end

  module Instance_Num_NumMult_Num_integer = struct

    val * : Num.integer -> Num.integer -> Num.integer

  end

  module Instance_Num_NumMult_Num_natural = struct

    val * : Num.natural -> Num.natural -> Num.natural

  end

  module Instance_Num_NumMult_Word_bitSequence = struct

    val * : Word.bitSequence -> Word.bitSequence -> Word.bitSequence

  end

  module Instance_Num_NumMult_nat = struct

    val * : nat -> nat -> nat

  end

  module Instance_Num_NumNegate_Num_int = struct

    val ~ : Num.int -> Num.int

  end

  module Instance_Num_NumNegate_Num_int32 = struct

    val ~ : Num.int32 -> Num.int32

  end

  module Instance_Num_NumNegate_Num_int64 = struct

    val ~ : Num.int64 -> Num.int64

  end

  module Instance_Num_NumNegate_Num_integer = struct

    val ~ : Num.integer -> Num.integer

  end

  module Instance_Num_NumNegate_Word_bitSequence = struct

    val ~ : Word.bitSequence -> Word.bitSequence

  end

  module Instance_Num_NumPow_Num_int = struct

    val ** : Num.int -> nat -> Num.int

  end

  module Instance_Num_NumPow_Num_int32 = struct

    val ** : Num.int32 -> nat -> Num.int32

  end

  module Instance_Num_NumPow_Num_int64 = struct

    val ** : Num.int64 -> nat -> Num.int64

  end

  module Instance_Num_NumPow_Num_integer = struct

    val ** : Num.integer -> nat -> Num.integer

  end

  module Instance_Num_NumPow_Num_natural = struct

    val ** : Num.natural -> nat -> Num.natural

  end

  module Instance_Num_NumPow_Word_bitSequence = struct

    val ** : Word.bitSequence -> nat -> Word.bitSequence

  end

  module Instance_Num_NumPow_nat = struct

    val ** : nat -> nat -> nat

  end

  module Instance_Num_NumPred_Num_int = struct

    val pred : Num.int -> Num.int

  end

  module Instance_Num_NumPred_Num_int32 = struct

    val pred : Num.int32 -> Num.int32

  end

  module Instance_Num_NumPred_Num_int64 = struct

    val pred : Num.int64 -> Num.int64

  end

  module Instance_Num_NumPred_Num_integer = struct

    val pred : Num.integer -> Num.integer

  end

  module Instance_Num_NumPred_Num_natural = struct

    val pred : Num.natural -> Num.natural

  end

  module Instance_Num_NumPred_Word_bitSequence = struct

    val pred : Word.bitSequence -> Word.bitSequence

  end

  module Instance_Num_NumPred_nat = struct

    val pred : nat -> nat

  end

  module Instance_Num_NumRemainder_Num_int = struct

    val mod : Num.int -> Num.int -> Num.int

  end

  module Instance_Num_NumRemainder_Num_int32 = struct

    val mod : Num.int32 -> Num.int32 -> Num.int32

  end

  module Instance_Num_NumRemainder_Num_int64 = struct

    val mod : Num.int64 -> Num.int64 -> Num.int64

  end

  module Instance_Num_NumRemainder_Num_integer = struct

    val mod : Num.integer -> Num.integer -> Num.integer

  end

  module Instance_Num_NumRemainder_Num_natural = struct

    val mod : Num.natural -> Num.natural -> Num.natural

  end

  module Instance_Num_NumRemainder_Word_bitSequence = struct

    val mod : Word.bitSequence -> Word.bitSequence -> Word.bitSequence

  end

  module Instance_Num_NumRemainder_nat = struct

    val mod : nat -> nat -> nat

  end

  module Instance_Num_NumSucc_Num_int = struct

    val succ : Num.int -> Num.int

  end

  module Instance_Num_NumSucc_Num_int32 = struct

    val succ : Num.int32 -> Num.int32

  end

  module Instance_Num_NumSucc_Num_int64 = struct

    val succ : Num.int64 -> Num.int64

  end

  module Instance_Num_NumSucc_Num_integer = struct

    val succ : Num.integer -> Num.integer

  end

  module Instance_Num_NumSucc_Num_natural = struct

    val succ : Num.natural -> Num.natural

  end

  module Instance_Num_NumSucc_Word_bitSequence = struct

    val succ : Word.bitSequence -> Word.bitSequence

  end

  module Instance_Num_NumSucc_nat = struct

    val succ : nat -> nat

  end

  module Instance_Num_Numeral_Num_int = struct

    val fromNumeral : numeral -> Num.int

  end

  module Instance_Num_Numeral_Num_int32 = struct

    val fromNumeral : numeral -> Num.int32

  end

  module Instance_Num_Numeral_Num_int64 = struct

    val fromNumeral : numeral -> Num.int64

  end

  module Instance_Num_Numeral_Num_integer = struct

    val fromNumeral : numeral -> Num.integer

  end

  module Instance_Num_Numeral_Num_natural = struct

    val fromNumeral : numeral -> Num.natural

  end

  module Instance_Num_Numeral_Word_bitSequence = struct

    val fromNumeral : numeral -> Word.bitSequence

  end

  module Instance_Num_Numeral_nat = struct

    val fromNumeral : numeral -> nat

  end

  module Instance_Word_WordAnd_Num_int = struct

    val land : Num.int -> Num.int -> Num.int

  end

  module Instance_Word_WordAnd_Num_int32 = struct

    val land : Num.int32 -> Num.int32 -> Num.int32

  end

  module Instance_Word_WordAnd_Num_int64 = struct

    val land : Num.int64 -> Num.int64 -> Num.int64

  end

  module Instance_Word_WordAnd_Num_integer = struct

    val land : Num.integer -> Num.integer -> Num.integer

  end

  module Instance_Word_WordAnd_Num_natural = struct

    val land : Num.natural -> Num.natural -> Num.natural

  end

  module Instance_Word_WordAnd_Word_bitSequence = struct

    val land : Word.bitSequence -> Word.bitSequence -> Word.bitSequence

  end

  module Instance_Word_WordAnd_nat = struct

    val land : nat -> nat -> nat

  end

  module Instance_Word_WordAsr_Num_int = struct

    val asr : Num.int -> nat -> Num.int

  end

  module Instance_Word_WordAsr_Num_int32 = struct

    val asr : Num.int32 -> nat -> Num.int32

  end

  module Instance_Word_WordAsr_Num_int64 = struct

    val asr : Num.int64 -> nat -> Num.int64

  end

  module Instance_Word_WordAsr_Num_integer = struct

    val asr : Num.integer -> nat -> Num.integer

  end

  module Instance_Word_WordAsr_Num_natural = struct

    val asr : Num.natural -> nat -> Num.natural

  end

  module Instance_Word_WordAsr_Word_bitSequence = struct

    val asr : Word.bitSequence -> nat -> Word.bitSequence

  end

  module Instance_Word_WordAsr_nat = struct

    val asr : nat -> nat -> nat

  end

  module Instance_Word_WordLsl_Num_int = struct

    val lsl : Num.int -> nat -> Num.int

  end

  module Instance_Word_WordLsl_Num_int32 = struct

    val lsl : Num.int32 -> nat -> Num.int32

  end

  module Instance_Word_WordLsl_Num_int64 = struct

    val lsl : Num.int64 -> nat -> Num.int64

  end

  module Instance_Word_WordLsl_Num_integer = struct

    val lsl : Num.integer -> nat -> Num.integer

  end

  module Instance_Word_WordLsl_Num_natural = struct

    val lsl : Num.natural -> nat -> Num.natural

  end

  module Instance_Word_WordLsl_Word_bitSequence = struct

    val lsl : Word.bitSequence -> nat -> Word.bitSequence

  end

  module Instance_Word_WordLsl_nat = struct

    val lsl : nat -> nat -> nat

  end

  module Instance_Word_WordLsr_Num_int32 = struct

    val lsr : Num.int32 -> nat -> Num.int32

  end

  module Instance_Word_WordLsr_Num_int64 = struct

    val lsr : Num.int64 -> nat -> Num.int64

  end

  module Instance_Word_WordLsr_Num_integer = struct

    val lsr : Num.integer -> nat -> Num.integer

  end

  module Instance_Word_WordLsr_Num_natural = struct

    val lsr : Num.natural -> nat -> Num.natural

  end

  module Instance_Word_WordLsr_Word_bitSequence = struct

    val lsr : Word.bitSequence -> nat -> Word.bitSequence

  end

  module Instance_Word_WordNot_Num_int = struct

    val lnot : Num.int -> Num.int

  end

  module Instance_Word_WordNot_Num_int32 = struct

    val lnot : Num.int32 -> Num.int32

  end

  module Instance_Word_WordNot_Num_int64 = struct

    val lnot : Num.int64 -> Num.int64

  end

  module Instance_Word_WordNot_Num_integer = struct

    val lnot : Num.integer -> Num.integer

  end

  module Instance_Word_WordNot_Word_bitSequence = struct

    val lnot : Word.bitSequence -> Word.bitSequence

  end

  module Instance_Word_WordOr_Num_int = struct

    val lor : Num.int -> Num.int -> Num.int

  end

  module Instance_Word_WordOr_Num_int32 = struct

    val lor : Num.int32 -> Num.int32 -> Num.int32

  end

  module Instance_Word_WordOr_Num_int64 = struct

    val lor : Num.int64 -> Num.int64 -> Num.int64

  end

  module Instance_Word_WordOr_Num_integer = struct

    val lor : Num.integer -> Num.integer -> Num.integer

  end

  module Instance_Word_WordOr_Num_natural = struct

    val lor : Num.natural -> Num.natural -> Num.natural

  end

  module Instance_Word_WordOr_Word_bitSequence = struct

    val lor : Word.bitSequence -> Word.bitSequence -> Word.bitSequence

  end

  module Instance_Word_WordOr_nat = struct

    val lor : nat -> nat -> nat

  end

  module Instance_Word_WordXor_Num_int = struct

    val lxor : Num.int -> Num.int -> Num.int

  end

  module Instance_Word_WordXor_Num_int32 = struct

    val lxor : Num.int32 -> Num.int32 -> Num.int32

  end

  module Instance_Word_WordXor_Num_int64 = struct

    val lxor : Num.int64 -> Num.int64 -> Num.int64

  end

  module Instance_Word_WordXor_Num_integer = struct

    val lxor : Num.integer -> Num.integer -> Num.integer

  end

  module Instance_Word_WordXor_Num_natural = struct

    val lxor : Num.natural -> Num.natural -> Num.natural

  end

  module Instance_Word_WordXor_Word_bitSequence = struct

    val lxor : Word.bitSequence -> Word.bitSequence -> Word.bitSequence

  end

  module Instance_Word_WordXor_nat = struct

    val lxor : nat -> nat -> nat

  end

end

module Relation = struct
  type rel 'a 'b = Relation.rel_set 'a 'b
  type rel_pred 'a 'b = 'a -> 'b -> bool
  type rel_set 'a 'b = set ('a * 'b)

  val inRel : forall 'a 'b. 
                (Basic_classes.SetType 'a) (Basic_classes.SetType 'b)
                  (Basic_classes.Eq 'a) (Basic_classes.Eq 'b) => 
                  'a -> 'b -> (Relation.rel 'a 'b) -> bool
  val isAntisymmetric : forall 'a. 
                          (Basic_classes.SetType 'a)
                            (Basic_classes.Eq 'a) => 
                            (Relation.rel 'a 'a) -> bool
  val isAntisymmetricOn : forall 'a. 
                            (Basic_classes.SetType 'a)
                              (Basic_classes.Eq 'a) => 
                              (Relation.rel 'a 'a) -> (set 'a) -> bool
  val isEquivalence : forall 'a. 
                        (Basic_classes.SetType 'a) (Basic_classes.Eq 'a) => 
                          (Relation.rel 'a 'a) -> bool
  val isEquivalenceOn : forall 'a. 
                          (Basic_classes.SetType 'a)
                            (Basic_classes.Eq 'a) => 
                            (Relation.rel 'a 'a) -> (set 'a) -> bool
  val isIrreflexive : forall 'a. 
                        (Basic_classes.SetType 'a) (Basic_classes.Eq 'a) => 
                          (Relation.rel 'a 'a) -> bool
  val isIrreflexiveOn : forall 'a. 
                          (Basic_classes.SetType 'a)
                            (Basic_classes.Eq 'a) => 
                            (Relation.rel 'a 'a) -> (set 'a) -> bool
  val isPartialOrder : forall 'a. 
                         (Basic_classes.SetType 'a) (Basic_classes.Eq 'a) => 
                           (Relation.rel 'a 'a) -> bool
  val isPartialOrderOn : forall 'a. 
                           (Basic_classes.SetType 'a)
                             (Basic_classes.Eq 'a) => 
                             (Relation.rel 'a 'a) -> (set 'a) -> bool
  val isPreorder : forall 'a. 
                     (Basic_classes.SetType 'a) (Basic_classes.Eq 'a) => 
                       (Relation.rel 'a 'a) -> bool
  val isPreorderOn : forall 'a. 
                       (Basic_classes.SetType 'a) (Basic_classes.Eq 'a) => 
                         (Relation.rel 'a 'a) -> (set 'a) -> bool
  val isReflexive : forall 'a. 
                      (Basic_classes.SetType 'a) (Basic_classes.Eq 'a) => 
                        (Relation.rel 'a 'a) -> bool
  val isReflexiveOn : forall 'a. 
                        (Basic_classes.SetType 'a) (Basic_classes.Eq 'a) => 
                          (Relation.rel 'a 'a) -> (set 'a) -> bool
  val isSingleValued : forall 'a 'b. 
                         (Basic_classes.SetType 'a)
                           (Basic_classes.SetType 'b) (Basic_classes.Eq 'a)
                           (Basic_classes.Eq 'b) => 
                           (Relation.rel 'a 'b) -> bool
  val isStrictPartialOrder : forall 'a. 
                               (Basic_classes.SetType 'a)
                                 (Basic_classes.Eq 'a) => 
                                 (Relation.rel 'a 'a) -> bool
  val isStrictPartialOrderOn : forall 'a. 
                                 (Basic_classes.SetType 'a)
                                   (Basic_classes.Eq 'a) => 
                                   (Relation.rel 'a 'a) -> (set 'a) -> bool
  val isStrictTotalOrder : forall 'a. 
                             (Basic_classes.SetType 'a)
                               (Basic_classes.Eq 'a) => 
                               (Relation.rel 'a 'a) -> bool
  val isStrictTotalOrderOn : forall 'a. 
                               (Basic_classes.SetType 'a)
                                 (Basic_classes.Eq 'a) => 
                                 (Relation.rel 'a 'a) -> (set 'a) -> bool
  val isSubrel : forall 'a 'b. 
                   (Basic_classes.SetType 'a) (Basic_classes.SetType 'b)
                     (Basic_classes.Eq 'a) (Basic_classes.Eq 'b) => 
                     (Relation.rel 'a 'b) -> (Relation.rel 'a 'b) -> bool
  val isSymmetric : forall 'a. 
                      (Basic_classes.SetType 'a) (Basic_classes.Eq 'a) => 
                        (Relation.rel 'a 'a) -> bool
  val isSymmetricOn : forall 'a. 
                        (Basic_classes.SetType 'a) (Basic_classes.Eq 'a) => 
                          (Relation.rel 'a 'a) -> (set 'a) -> bool
  val isTotal : forall 'a. 
                  (Basic_classes.SetType 'a) (Basic_classes.Eq 'a) => 
                    (Relation.rel 'a 'a) -> bool
  val isTotalOn : forall 'a. 
                    (Basic_classes.SetType 'a) (Basic_classes.Eq 'a) => 
                      (Relation.rel 'a 'a) -> (set 'a) -> bool
  val isTotalOrder : forall 'a. 
                       (Basic_classes.SetType 'a) (Basic_classes.Eq 'a) => 
                         (Relation.rel 'a 'a) -> bool
  val isTotalOrderOn : forall 'a. 
                         (Basic_classes.SetType 'a) (Basic_classes.Eq 'a) => 
                           (Relation.rel 'a 'a) -> (set 'a) -> bool
  val isTransitive : forall 'a. 
                       (Basic_classes.SetType 'a) (Basic_classes.Eq 'a) => 
                         (Relation.rel 'a 'a) -> bool
  val isTransitiveOn : forall 'a. 
                         (Basic_classes.SetType 'a) (Basic_classes.Eq 'a) => 
                           (Relation.rel 'a 'a) -> (set 'a) -> bool
  val isTrichotomous : forall 'a. 
                         (Basic_classes.SetType 'a) (Basic_classes.Eq 'a) => 
                           (Relation.rel 'a 'a) -> bool
  val isTrichotomousOn : forall 'a. 
                           (Basic_classes.SetType 'a)
                             (Basic_classes.Eq 'a) => 
                             (Relation.rel 'a 'a) -> (set 'a) -> bool
  val isWellFounded : forall 'a. 
                        (Basic_classes.SetType 'a) (Basic_classes.Eq 'a) => 
                          (Relation.rel 'a 'a) -> bool
  val reflexivTransitiveClosure : forall 'a. 
                                    (Basic_classes.SetType 'a)
                                      (Basic_classes.Eq 'a) => 
                                      (Relation.rel 'a 'a) -> Relation.rel 
                                                              'a 'a
  val reflexivTransitiveClosureOn : forall 'a. 
                                      (Basic_classes.SetType 'a)
                                        (Basic_classes.Eq 'a) => 
                                        (Relation.rel 'a 'a) -> (set 'a) -> 
                                                                Relation.rel 
                                                                'a 'a
  val relAdd : forall 'a 'b. 
                 (Basic_classes.SetType 'a) (Basic_classes.SetType 'b) => 
                   'a -> 'b -> (Relation.rel 'a 'b) -> Relation.rel 'a 'b
  val relApply : forall 'a 'b. 
                   (Basic_classes.SetType 'a) (Basic_classes.SetType 'b)
                     (Basic_classes.Eq 'a) => 
                     (Relation.rel 'a 'b) -> (set 'a) -> set 'b
  val relComp : forall 'a 'b 'c. 
                  (Basic_classes.SetType 'a) (Basic_classes.SetType 'b)
                    (Basic_classes.SetType 'c) (Basic_classes.Eq 'a)
                    (Basic_classes.Eq 'b) => 
                    (Relation.rel 'a 'b) -> (Relation.rel 'b 'c) -> Relation.rel 
                                                                    'a 
                                                                    'c
  val relConverse : forall 'a 'b. 
                      (Basic_classes.SetType 'a)
                        (Basic_classes.SetType 'b) => 
                        (Relation.rel 'a 'b) -> Relation.rel 'b 'a
  val relDefinedOn : forall 'a. 
                       (Basic_classes.SetType 'a) => 
                         (Relation.rel 'a 'a) -> set 'a
  val relDomain : forall 'a 'b. 
                    (Basic_classes.SetType 'a) (Basic_classes.SetType 'b) => 
                      (Relation.rel 'a 'b) -> set 'a
  val relEmpty : forall 'a 'b. 
                   (Basic_classes.SetType 'a) (Basic_classes.SetType 'b) => 
                     Relation.rel 'a 'b
  val relEq : forall 'a 'b. 
                (Basic_classes.SetType 'a) (Basic_classes.SetType 'b) => 
                  (Relation.rel 'a 'b) -> (Relation.rel 'a 'b) -> bool
  val relFromPred : forall 'a 'b. 
                      (Basic_classes.SetType 'a) (Basic_classes.SetType 'b)
                        (Basic_classes.Eq 'a) (Basic_classes.Eq 'b) => 
                        (set 'a) -> (set 'b) -> (Relation.rel_pred 'a 'b) -> 
                                                Relation.rel 'a 'b
  val relFromSet : forall 'a 'b. 
                     (Basic_classes.SetType 'a)
                       (Basic_classes.SetType 'b) => 
                       (Relation.rel_set 'a 'b) -> Relation.rel 'a 'b
  val relId : forall 'a. 
                (Basic_classes.SetType 'a) (Basic_classes.Eq 'a) => 
                  Relation.rel 'a 'a
  val relIdOn : forall 'a. 
                  (Basic_classes.SetType 'a) (Basic_classes.Eq 'a) => 
                    (set 'a) -> Relation.rel 'a 'a
  val relIntersection : forall 'a 'b. 
                          (Basic_classes.SetType 'a)
                            (Basic_classes.SetType 'b) (Basic_classes.Eq 'a)
                            (Basic_classes.Eq 'b) => 
                            (Relation.rel 'a 'b) -> (Relation.rel 'a 'b) -> 
                                                    Relation.rel 'a 'b
  val relOver : forall 'a. 
                  (Basic_classes.SetType 'a) => 
                    (Relation.rel 'a 'a) -> (set 'a) -> bool
  val relRange : forall 'a 'b. 
                   (Basic_classes.SetType 'a) (Basic_classes.SetType 'b) => 
                     (Relation.rel 'a 'b) -> set 'b
  val relRestrict : forall 'a. 
                      (Basic_classes.SetType 'a) (Basic_classes.Eq 'a) => 
                        (Relation.rel 'a 'a) -> (set 'a) -> Relation.rel 
                                                            'a 'a
  val relToPred : forall 'a 'b. 
                    (Basic_classes.SetType 'a) (Basic_classes.SetType 'b)
                      (Basic_classes.Eq 'a) (Basic_classes.Eq 'b) => 
                      (Relation.rel 'a 'b) -> Relation.rel_pred 'a 'b
  val relToSet : forall 'a 'b. 
                   (Basic_classes.SetType 'a) (Basic_classes.SetType 'b) => 
                     (Relation.rel 'a 'b) -> Relation.rel_set 'a 'b
  val relUnion : forall 'a 'b. 
                   (Basic_classes.SetType 'a) (Basic_classes.SetType 'b) => 
                     (Relation.rel 'a 'b) -> (Relation.rel 'a 'b) -> 
                                             Relation.rel 'a 'b
  val transitiveClosure : forall 'a. 
                            (Basic_classes.SetType 'a)
                              (Basic_classes.Eq 'a) => 
                              (Relation.rel 'a 'a) -> Relation.rel 'a 'a
  val transitiveClosureAdd : forall 'a. 
                               (Basic_classes.SetType 'a)
                                 (Basic_classes.Eq 'a) => 
                                 'a -> 'a -> (Relation.rel 'a 'a) -> 
                                             Relation.rel 'a 'a
  val transitiveClosureByCmp : forall 'a. 
                                 (('a * 'a) -> ('a * 'a) -> Basic_classes.ordering) -> 
                                 (Relation.rel 'a 'a) -> Relation.rel 'a 'a
  val transitiveClosureByEq : forall 'a. 
                                ('a -> 'a -> bool) -> (Relation.rel 'a 'a) -> 
                                                      Relation.rel 'a 'a

end

module Set = struct

  val IN : forall 'a. (Basic_classes.SetType 'a) => 'a -> (set 'a) -> bool
  val NIN : forall 'a. (Basic_classes.SetType 'a) => 'a -> (set 'a) -> bool
  val \ : forall 'a. 
            (Basic_classes.SetType 'a) => (set 'a) -> (set 'a) -> set 'a
  val all : forall 'a. 
              (Basic_classes.SetType 'a) => ('a -> bool) -> (set 'a) -> bool
  val any : forall 'a. 
              (Basic_classes.SetType 'a) => ('a -> bool) -> (set 'a) -> bool
  val bigunion : forall 'a. 
                   (Basic_classes.SetType 'a) => (set (set 'a)) -> set 'a
  val bigunionBy : forall 'a. 
                     ('a -> 'a -> Basic_classes.ordering) -> (set (set 'a)) -> 
                                                             set 'a
  val cross : forall 'a 'b. 
                (Basic_classes.SetType 'a) (Basic_classes.SetType 'b) => 
                  (set 'a) -> (set 'b) -> set ('a * 'b)
  val crossBy : forall 'a 'b. 
                  (('a * 'b) -> ('a * 'b) -> Basic_classes.ordering) -> 
                  (set 'a) -> (set 'b) -> set ('a * 'b)
  val delete : forall 'a. 
                 (Basic_classes.SetType 'a) (Basic_classes.Eq 'a) => 
                   'a -> (set 'a) -> set 'a
  val deleteBy : forall 'a. 
                   (Basic_classes.SetType 'a) => 
                     ('a -> 'a -> bool) -> 'a -> (set 'a) -> set 'a
  val difference : forall 'a. 
                     (Basic_classes.SetType 'a) => 
                       (set 'a) -> (set 'a) -> set 'a
  val differenceBy : forall 'a. 
                       ('a -> 'a -> Basic_classes.ordering) -> (set 'a) -> 
                                                               (set 'a) -> 
                                                               set 'a
  val empty : forall 'a. (Basic_classes.SetType 'a) => set 'a
  val emptyBy : forall 'a. ('a -> 'a -> Basic_classes.ordering) -> set 'a
  val filter : forall 'a. 
                 (Basic_classes.SetType 'a) => 
                   ('a -> bool) -> (set 'a) -> set 'a
  val findMax : forall 'a. 
                  (Basic_classes.SetType 'a) (Basic_classes.Eq 'a) => 
                    (set 'a) -> Maybe.maybe 'a
  val findMin : forall 'a. 
                  (Basic_classes.SetType 'a) (Basic_classes.Eq 'a) => 
                    (set 'a) -> Maybe.maybe 'a
  val finite : forall 'a. (Basic_classes.SetType 'a) => (set 'a) -> bool
  val fromList : forall 'a. (Basic_classes.SetType 'a) => (list 'a) -> set 'a
  val fromListBy : forall 'a. 
                     ('a -> 'a -> Basic_classes.ordering) -> (list 'a) -> 
                                                             set 'a
  val insert : forall 'a. 
                 (Basic_classes.SetType 'a) => 'a -> (set 'a) -> set 'a
  val instance_Basic_classes_Eq_set_dict : forall 'a. 
                                             (Basic_classes.SetType 'a) => 
                                               Basic_classes.Eq_class 
                                               (set 'a)
  val instance_Basic_classes_SetType_set_dict : forall 'a. 
                                                  (Basic_classes.SetType 'a) => 
                                                    Basic_classes.SetType_class 
                                                    (set 'a)
  val inter : forall 'a. 
                (Basic_classes.SetType 'a) => (set 'a) -> (set 'a) -> set 'a
  val intersection : forall 'a. 
                       (Basic_classes.SetType 'a) => 
                         (set 'a) -> (set 'a) -> set 'a
  val intersectionBy : forall 'a. 
                         ('a -> 'a -> Basic_classes.ordering) -> (set 'a) -> 
                                                                 (set 'a) -> 
                                                                 set 
                                                                 'a
  val isProperSubsetOf : forall 'a. 
                           (Basic_classes.SetType 'a) => 
                             (set 'a) -> (set 'a) -> bool
  val isProperSubsetOfBy : forall 'a. 
                             ('a -> 'a -> Basic_classes.ordering) -> 
                             (set 'a) -> (set 'a) -> bool
  val isSubsetOf : forall 'a. 
                     (Basic_classes.SetType 'a) => 
                       (set 'a) -> (set 'a) -> bool
  val isSubsetOfBy : forall 'a. 
                       ('a -> 'a -> Basic_classes.ordering) -> (set 'a) -> 
                                                               (set 'a) -> 
                                                               bool
  val leastFixedPoint : forall 'a. 
                          (Basic_classes.SetType 'a) => 
                            nat -> ((set 'a) -> set 'a) -> (set 'a) -> set 'a
  val map : forall 'a 'b. 
              (Basic_classes.SetType 'a) (Basic_classes.SetType 'b) => 
                ('a -> 'b) -> (set 'a) -> set 'b
  val mapBy : forall 'a 'b. 
                ('b -> 'b -> Basic_classes.ordering) -> ('a -> 'b) -> 
                                                        (set 'a) -> set 'b
  val member : forall 'a. 
                 (Basic_classes.SetType 'a) => 'a -> (set 'a) -> bool
  val memberBy : forall 'a. 
                   ('a -> 'a -> Basic_classes.ordering) -> 'a -> (set 'a) -> 
                                                                 bool
  val notMember : forall 'a. 
                    (Basic_classes.SetType 'a) => 'a -> (set 'a) -> bool
  val null : forall 'a. (Basic_classes.SetType 'a) => (set 'a) -> bool
  val partition : forall 'a. 
                    (Basic_classes.SetType 'a) => 
                      ('a -> bool) -> (set 'a) -> ((set 'a) * (set 'a))
  val setCompare : forall 'a. 
                     (Basic_classes.SetType 'a) => 
                       (set 'a) -> (set 'a) -> Basic_classes.ordering
  val setCompareBy : forall 'a. 
                       ('a -> 'a -> Basic_classes.ordering) -> (set 'a) -> 
                                                               (set 'a) -> 
                                                               Basic_classes.ordering
  val setEqual : forall 'a. 
                   (Basic_classes.SetType 'a) => (set 'a) -> (set 'a) -> bool
  val setEqualBy : forall 'a. 
                     ('a -> 'a -> Basic_classes.ordering) -> (set 'a) -> 
                                                             (set 'a) -> 
                                                             bool
  val set_case : forall 'a 'b. 
                   (Basic_classes.SetType 'a) => 
                     (set 'a) -> 'b -> ('a -> 'b) -> 'b -> 'b
  val sigma : forall 'a 'b. 
                (Basic_classes.SetType 'a) (Basic_classes.SetType 'b) => 
                  (set 'a) -> ('a -> set 'b) -> set ('a * 'b)
  val sigmaBy : forall 'a 'b. 
                  (('a * 'b) -> ('a * 'b) -> Basic_classes.ordering) -> 
                  (set 'a) -> ('a -> set 'b) -> set ('a * 'b)
  val singleton : forall 'a. (Basic_classes.SetType 'a) => 'a -> set 'a
  val size : forall 'a. (Basic_classes.SetType 'a) => (set 'a) -> nat
  val split : forall 'a. 
                (Basic_classes.SetType 'a) (Basic_classes.Ord 'a) => 
                  'a -> (set 'a) -> ((set 'a) * (set 'a))
  val splitMember : forall 'a. 
                      (Basic_classes.SetType 'a) (Basic_classes.Ord 'a) => 
                        'a -> (set 'a) -> ((set 'a) * bool * (set 'a))
  val subset : forall 'a. 
                 (Basic_classes.SetType 'a) => (set 'a) -> (set 'a) -> bool
  val union : forall 'a. 
                (Basic_classes.SetType 'a) => (set 'a) -> (set 'a) -> set 'a
  val unionBy : forall 'a. 
                  ('a -> 'a -> Basic_classes.ordering) -> (set 'a) -> 
                                                          (set 'a) -> 
                                                          set 'a

  module Instance_Basic_classes_Eq_set = struct

    val <> : forall 'a. 
               (Basic_classes.SetType 'a) => (set 'a) -> (set 'a) -> bool
    val = : forall 'a. 
              (Basic_classes.SetType 'a) => (set 'a) -> (set 'a) -> bool

  end

  module Instance_Basic_classes_SetType_set = struct

    val setElemCompare : forall 'a. 
                           (Basic_classes.SetType 'a) => 
                             (set 'a) -> (set 'a) -> Basic_classes.ordering

  end

end

module Set_helpers = struct

  val fold : forall 'a 'b. ('a -> 'b -> 'b) -> (set 'a) -> 'b -> 'b

end

module Sorting = struct

  val insert : forall 'a. 
                 (Basic_classes.Ord 'a) => 'a -> (list 'a) -> list 'a
  val insertBy : forall 'a. ('a -> 'a -> bool) -> 'a -> (list 'a) -> list 'a
  val insertSort : forall 'a. (Basic_classes.Ord 'a) => (list 'a) -> list 'a
  val insertSortBy : forall 'a. ('a -> 'a -> bool) -> (list 'a) -> list 'a
  val isPermutation : forall 'a. 
                        (Basic_classes.Eq 'a) => 
                          (list 'a) -> (list 'a) -> bool
  val isPermutationBy : forall 'a. 
                          ('a -> 'a -> bool) -> (list 'a) -> (list 'a) -> 
                                                             bool
  val isSorted : forall 'a. (Basic_classes.Ord 'a) => (list 'a) -> bool
  val isSortedBy : forall 'a. ('a -> 'a -> bool) -> (list 'a) -> bool
  val sort : forall 'a. (Basic_classes.Ord 'a) => (list 'a) -> list 'a
  val sortBy : forall 'a. ('a -> 'a -> bool) -> (list 'a) -> list 'a
  val sortByOrd : forall 'a. 
                    ('a -> 'a -> Basic_classes.ordering) -> (list 'a) -> 
                                                            list 'a

end

module String = struct

  val ^ : string -> string -> string
  val cons_string : char -> string -> string
  val empty_string : string
  val makeString : nat -> char -> string
  val stringAppend : string -> string -> string
  val stringLength : string -> nat
  val string_case : forall 'a. string -> 'a -> (char -> string -> 'a) -> 'a
  val toCharList : string -> list char
  val toString : (list char) -> string

end

module Tuple = struct

  val curry : forall 'a 'b 'c. (('a * 'b) -> 'c) -> 'a -> 'b -> 'c
  val fst : forall 'a 'b. ('a * 'b) -> 'a
  val snd : forall 'a 'b. ('a * 'b) -> 'b
  val swap : forall 'a 'b. ('a * 'b) -> ('b * 'a)
  val uncurry : forall 'a 'b 'c. ('a -> 'b -> 'c) -> ('a * 'b) -> 'c

end

module Word = struct
  class WordAnd
  type WordAnd_class 'a = {
      val land_method : forall 'a. (Word.WordAnd_class 'a) -> 'a -> 'a -> 'a

  }
  class WordAsr
  type WordAsr_class 'a = {
      val asr_method : forall 'a. (Word.WordAsr_class 'a) -> 'a -> nat -> 'a

  }
  class WordLsl
  type WordLsl_class 'a = {
      val lsl_method : forall 'a. (Word.WordLsl_class 'a) -> 'a -> nat -> 'a

  }
  class WordLsr
  type WordLsr_class 'a = {
      val lsr_method : forall 'a. (Word.WordLsr_class 'a) -> 'a -> nat -> 'a

  }
  class WordNot
  type WordNot_class 'a = {
      val lnot_method : forall 'a. (Word.WordNot_class 'a) -> 'a -> 'a

  }
  class WordOr
  type WordOr_class 'a = {
      val lor_method : forall 'a. (Word.WordOr_class 'a) -> 'a -> 'a -> 'a

  }
  class WordXor
  type WordXor_class 'a = {
      val lxor_method : forall 'a. (Word.WordXor_class 'a) -> 'a -> 'a -> 'a

  }
  type bitSequence

  val BitSeq : (Maybe.maybe nat) -> bool -> (list bool) -> Word.bitSequence
  val arithmetic_right_shift : forall 'a. 
                                 (Word.WordAsr 'a) => 'a -> nat -> 'a
  val asr : forall 'a. (Word.WordAsr 'a) => 'a -> nat -> 'a
  val bitSeqAdd : Word.bitSequence -> Word.bitSequence -> Word.bitSequence
  val bitSeqAnd : Word.bitSequence -> Word.bitSequence -> Word.bitSequence
  val bitSeqArithBinOp : 
                           (Num.integer -> Num.integer -> Num.integer) -> 
                           Word.bitSequence -> Word.bitSequence -> Word.bitSequence
  val bitSeqArithBinTest : forall 'a. 
                             (Num.integer -> Num.integer -> 'a) -> Word.bitSequence -> 
                                                                   Word.bitSequence -> 
                                                                   'a
  val bitSeqArithUnaryOp : 
                             (Num.integer -> Num.integer) -> Word.bitSequence -> 
                                                             Word.bitSequence
  val bitSeqArithmeticShiftRight : 
                                     Word.bitSequence -> nat -> Word.bitSequence
  val bitSeqBinop : 
                      (bool -> bool -> bool) -> Word.bitSequence -> Word.bitSequence -> 
                                                                    Word.bitSequence
  val bitSeqBinopAux : 
                         (bool -> bool -> bool) -> bool -> (list bool) -> 
                                                           bool -> (list 
                                                                   bool) -> 
                                                                   list 
                                                                   bool
  val bitSeqCompare : 
                        Word.bitSequence -> Word.bitSequence -> Basic_classes.ordering
  val bitSeqDiv : Word.bitSequence -> Word.bitSequence -> Word.bitSequence
  val bitSeqEq : Word.bitSequence -> Word.bitSequence -> bool
  val bitSeqFromBoolList : (list bool) -> Maybe.maybe Word.bitSequence
  val bitSeqFromInt : Num.int -> Word.bitSequence
  val bitSeqFromInteger : 
                            (Maybe.maybe nat) -> Num.integer -> Word.bitSequence
  val bitSeqFromNat : nat -> Word.bitSequence
  val bitSeqFromNatural : 
                            (Maybe.maybe nat) -> Num.natural -> Word.bitSequence
  val bitSeqFromNumeral : numeral -> Word.bitSequence
  val bitSeqGreater : Word.bitSequence -> Word.bitSequence -> bool
  val bitSeqGreaterEqual : Word.bitSequence -> Word.bitSequence -> bool
  val bitSeqLess : Word.bitSequence -> Word.bitSequence -> bool
  val bitSeqLessEqual : Word.bitSequence -> Word.bitSequence -> bool
  val bitSeqLogicalShiftRight : Word.bitSequence -> nat -> Word.bitSequence
  val bitSeqMax : Word.bitSequence -> Word.bitSequence -> Word.bitSequence
  val bitSeqMin : Word.bitSequence -> Word.bitSequence -> Word.bitSequence
  val bitSeqMinus : Word.bitSequence -> Word.bitSequence -> Word.bitSequence
  val bitSeqMod : Word.bitSequence -> Word.bitSequence -> Word.bitSequence
  val bitSeqMult : Word.bitSequence -> Word.bitSequence -> Word.bitSequence
  val bitSeqNegate : Word.bitSequence -> Word.bitSequence
  val bitSeqNot : Word.bitSequence -> Word.bitSequence
  val bitSeqOr : Word.bitSequence -> Word.bitSequence -> Word.bitSequence
  val bitSeqPow : Word.bitSequence -> nat -> Word.bitSequence
  val bitSeqPred : Word.bitSequence -> Word.bitSequence
  val bitSeqSetBit : Word.bitSequence -> nat -> bool -> Word.bitSequence
  val bitSeqShiftLeft : Word.bitSequence -> nat -> Word.bitSequence
  val bitSeqSucc : Word.bitSequence -> Word.bitSequence
  val bitSeqTestBit : Word.bitSequence -> nat -> Maybe.maybe bool
  val bitSeqXor : Word.bitSequence -> Word.bitSequence -> Word.bitSequence
  val boolListFromInteger : Num.integer -> (bool * (list bool))
  val boolListFromIntegerAux : (list bool) -> Num.integer -> list bool
  val boolListFromNatural : (list bool) -> Num.natural -> list bool
  val boolListFrombitSeq : nat -> Word.bitSequence -> list bool
  val boolListFrombitSeqAux : forall 'a. nat -> 'a -> (list 'a) -> list 'a
  val cleanBitSeq : Word.bitSequence -> Word.bitSequence
  val conjunction : forall 'a. (Word.WordAnd 'a) => 'a -> 'a -> 'a
  val defaultAsr : forall 'a. 
                     (Word.bitSequence -> 'a) -> ('a -> Word.bitSequence) -> 
                                                 'a -> nat -> 'a
  val defaultLand : forall 'a. 
                      (Word.bitSequence -> 'a) -> ('a -> Word.bitSequence) -> 
                                                  'a -> 'a -> 'a
  val defaultLnot : forall 'a. 
                      (Word.bitSequence -> 'a) -> ('a -> Word.bitSequence) -> 
                                                  'a -> 'a
  val defaultLor : forall 'a. 
                     (Word.bitSequence -> 'a) -> ('a -> Word.bitSequence) -> 
                                                 'a -> 'a -> 'a
  val defaultLsl : forall 'a. 
                     (Word.bitSequence -> 'a) -> ('a -> Word.bitSequence) -> 
                                                 'a -> nat -> 'a
  val defaultLsr : forall 'a. 
                     (Word.bitSequence -> 'a) -> ('a -> Word.bitSequence) -> 
                                                 'a -> nat -> 'a
  val defaultLxor : forall 'a. 
                      (Word.bitSequence -> 'a) -> ('a -> Word.bitSequence) -> 
                                                  'a -> 'a -> 'a
  val exclusive_or : forall 'a. (Word.WordXor 'a) => 'a -> 'a -> 'a
  val inclusive_or : forall 'a. (Word.WordOr 'a) => 'a -> 'a -> 'a
  val instance_Basic_classes_Eq_Word_bitSequence_dict : 
                                                          Basic_classes.Eq_class 
                                                          Word.bitSequence
  val instance_Basic_classes_OrdMaxMin_Word_bitSequence_dict : 
                                                                 Basic_classes.OrdMaxMin_class 
                                                                 Word.bitSequence
  val instance_Basic_classes_Ord_Word_bitSequence_dict : 
                                                           Basic_classes.Ord_class 
                                                           Word.bitSequence
  val instance_Basic_classes_SetType_Word_bitSequence_dict : 
                                                               Basic_classes.SetType_class 
                                                               Word.bitSequence
  val instance_Num_NumAdd_Word_bitSequence_dict : 
                                                    Num.NumAdd_class 
                                                    Word.bitSequence
  val instance_Num_NumDivision_Word_bitSequence_dict : 
                                                         Num.NumDivision_class 
                                                         Word.bitSequence
  val instance_Num_NumIntegerDivision_Word_bitSequence_dict : 
                                                                Num.NumIntegerDivision_class 
                                                                Word.bitSequence
  val instance_Num_NumMinus_Word_bitSequence_dict : 
                                                      Num.NumMinus_class 
                                                      Word.bitSequence
  val instance_Num_NumMult_Word_bitSequence_dict : 
                                                     Num.NumMult_class 
                                                     Word.bitSequence
  val instance_Num_NumNegate_Word_bitSequence_dict : 
                                                       Num.NumNegate_class 
                                                       Word.bitSequence
  val instance_Num_NumPow_Word_bitSequence_dict : 
                                                    Num.NumPow_class 
                                                    Word.bitSequence
  val instance_Num_NumPred_Word_bitSequence_dict : 
                                                     Num.NumPred_class 
                                                     Word.bitSequence
  val instance_Num_NumRemainder_Word_bitSequence_dict : 
                                                          Num.NumRemainder_class 
                                                          Word.bitSequence
  val instance_Num_NumSucc_Word_bitSequence_dict : 
                                                     Num.NumSucc_class 
                                                     Word.bitSequence
  val instance_Num_Numeral_Word_bitSequence_dict : 
                                                     Num.Numeral_class 
                                                     Word.bitSequence
  val instance_Word_WordAnd_Num_int32_dict : Word.WordAnd_class Num.int32
  val instance_Word_WordAnd_Num_int64_dict : Word.WordAnd_class Num.int64
  val instance_Word_WordAnd_Num_int_dict : Word.WordAnd_class Num.int
  val instance_Word_WordAnd_Num_integer_dict : Word.WordAnd_class Num.integer
  val instance_Word_WordAnd_Num_natural_dict : Word.WordAnd_class Num.natural
  val instance_Word_WordAnd_Word_bitSequence_dict : 
                                                      Word.WordAnd_class 
                                                      Word.bitSequence
  val instance_Word_WordAnd_nat_dict : Word.WordAnd_class nat
  val instance_Word_WordAsr_Num_int32_dict : Word.WordAsr_class Num.int32
  val instance_Word_WordAsr_Num_int64_dict : Word.WordAsr_class Num.int64
  val instance_Word_WordAsr_Num_int_dict : Word.WordAsr_class Num.int
  val instance_Word_WordAsr_Num_integer_dict : Word.WordAsr_class Num.integer
  val instance_Word_WordAsr_Num_natural_dict : Word.WordAsr_class Num.natural
  val instance_Word_WordAsr_Word_bitSequence_dict : 
                                                      Word.WordAsr_class 
                                                      Word.bitSequence
  val instance_Word_WordAsr_nat_dict : Word.WordAsr_class nat
  val instance_Word_WordLsl_Num_int32_dict : Word.WordLsl_class Num.int32
  val instance_Word_WordLsl_Num_int64_dict : Word.WordLsl_class Num.int64
  val instance_Word_WordLsl_Num_int_dict : Word.WordLsl_class Num.int
  val instance_Word_WordLsl_Num_integer_dict : Word.WordLsl_class Num.integer
  val instance_Word_WordLsl_Num_natural_dict : Word.WordLsl_class Num.natural
  val instance_Word_WordLsl_Word_bitSequence_dict : 
                                                      Word.WordLsl_class 
                                                      Word.bitSequence
  val instance_Word_WordLsl_nat_dict : Word.WordLsl_class nat
  val instance_Word_WordLsr_Num_int32_dict : Word.WordLsr_class Num.int32
  val instance_Word_WordLsr_Num_int64_dict : Word.WordLsr_class Num.int64
  val instance_Word_WordLsr_Num_integer_dict : Word.WordLsr_class Num.integer
  val instance_Word_WordLsr_Num_natural_dict : Word.WordLsr_class Num.natural
  val instance_Word_WordLsr_Word_bitSequence_dict : 
                                                      Word.WordLsr_class 
                                                      Word.bitSequence
  val instance_Word_WordNot_Num_int32_dict : Word.WordNot_class Num.int32
  val instance_Word_WordNot_Num_int64_dict : Word.WordNot_class Num.int64
  val instance_Word_WordNot_Num_int_dict : Word.WordNot_class Num.int
  val instance_Word_WordNot_Num_integer_dict : Word.WordNot_class Num.integer
  val instance_Word_WordNot_Word_bitSequence_dict : 
                                                      Word.WordNot_class 
                                                      Word.bitSequence
  val instance_Word_WordOr_Num_int32_dict : Word.WordOr_class Num.int32
  val instance_Word_WordOr_Num_int64_dict : Word.WordOr_class Num.int64
  val instance_Word_WordOr_Num_int_dict : Word.WordOr_class Num.int
  val instance_Word_WordOr_Num_integer_dict : Word.WordOr_class Num.integer
  val instance_Word_WordOr_Num_natural_dict : Word.WordOr_class Num.natural
  val instance_Word_WordOr_Word_bitSequence_dict : 
                                                     Word.WordOr_class 
                                                     Word.bitSequence
  val instance_Word_WordOr_nat_dict : Word.WordOr_class nat
  val instance_Word_WordXor_Num_int32_dict : Word.WordXor_class Num.int32
  val instance_Word_WordXor_Num_int64_dict : Word.WordXor_class Num.int64
  val instance_Word_WordXor_Num_int_dict : Word.WordXor_class Num.int
  val instance_Word_WordXor_Num_integer_dict : Word.WordXor_class Num.integer
  val instance_Word_WordXor_Num_natural_dict : Word.WordXor_class Num.natural
  val instance_Word_WordXor_Word_bitSequence_dict : 
                                                      Word.WordXor_class 
                                                      Word.bitSequence
  val instance_Word_WordXor_nat_dict : Word.WordXor_class nat
  val int32Asr : Num.int32 -> nat -> Num.int32
  val int32Land : Num.int32 -> Num.int32 -> Num.int32
  val int32Lnot : Num.int32 -> Num.int32
  val int32Lor : Num.int32 -> Num.int32 -> Num.int32
  val int32Lsl : Num.int32 -> nat -> Num.int32
  val int32Lsr : Num.int32 -> nat -> Num.int32
  val int32Lxor : Num.int32 -> Num.int32 -> Num.int32
  val int64Asr : Num.int64 -> nat -> Num.int64
  val int64Land : Num.int64 -> Num.int64 -> Num.int64
  val int64Lnot : Num.int64 -> Num.int64
  val int64Lor : Num.int64 -> Num.int64 -> Num.int64
  val int64Lsl : Num.int64 -> nat -> Num.int64
  val int64Lsr : Num.int64 -> nat -> Num.int64
  val int64Lxor : Num.int64 -> Num.int64 -> Num.int64
  val intAsr : Num.int -> nat -> Num.int
  val intFromBitSeq : Word.bitSequence -> Num.int
  val intLand : Num.int -> Num.int -> Num.int
  val intLnot : Num.int -> Num.int
  val intLor : Num.int -> Num.int -> Num.int
  val intLsl : Num.int -> nat -> Num.int
  val intLxor : Num.int -> Num.int -> Num.int
  val integerAsr : Num.integer -> nat -> Num.integer
  val integerFromBitSeq : Word.bitSequence -> Num.integer
  val integerFromBoolList : (bool * (list bool)) -> Num.integer
  val integerFromBoolListAux : Num.integer -> (list bool) -> Num.integer
  val integerLand : Num.integer -> Num.integer -> Num.integer
  val integerLnot : Num.integer -> Num.integer
  val integerLor : Num.integer -> Num.integer -> Num.integer
  val integerLsl : Num.integer -> nat -> Num.integer
  val integerLxor : Num.integer -> Num.integer -> Num.integer
  val land : forall 'a. (Word.WordAnd 'a) => 'a -> 'a -> 'a
  val left_shift : forall 'a. (Word.WordLsl 'a) => 'a -> nat -> 'a
  val lnot : forall 'a. (Word.WordNot 'a) => 'a -> 'a
  val logicial_right_shift : forall 'a. (Word.WordLsr 'a) => 'a -> nat -> 'a
  val lor : forall 'a. (Word.WordOr 'a) => 'a -> 'a -> 'a
  val lsl : forall 'a. (Word.WordLsl 'a) => 'a -> nat -> 'a
  val lsr : forall 'a. (Word.WordLsr 'a) => 'a -> nat -> 'a
  val lxor : forall 'a. (Word.WordXor 'a) => 'a -> 'a -> 'a
  val natAsr : nat -> nat -> nat
  val natFromBitSeq : Word.bitSequence -> nat
  val natLand : nat -> nat -> nat
  val natLor : nat -> nat -> nat
  val natLsl : nat -> nat -> nat
  val natLxor : nat -> nat -> nat
  val naturalAsr : Num.natural -> nat -> Num.natural
  val naturalFromBitSeq : Word.bitSequence -> Num.natural
  val naturalLand : Num.natural -> Num.natural -> Num.natural
  val naturalLor : Num.natural -> Num.natural -> Num.natural
  val naturalLsl : Num.natural -> nat -> Num.natural
  val naturalLxor : Num.natural -> Num.natural -> Num.natural
  val resizeBitSeq : 
                       (Maybe.maybe nat) -> Word.bitSequence -> Word.bitSequence

  module Instance_Basic_classes_Eq_Word_bitSequence = struct

    val <> : Word.bitSequence -> Word.bitSequence -> bool
    val = : Word.bitSequence -> Word.bitSequence -> bool

  end

  module Instance_Basic_classes_OrdMaxMin_Word_bitSequence = struct

    val max : Word.bitSequence -> Word.bitSequence -> Word.bitSequence
    val min : Word.bitSequence -> Word.bitSequence -> Word.bitSequence

  end

  module Instance_Basic_classes_Ord_Word_bitSequence = struct

    val < : Word.bitSequence -> Word.bitSequence -> bool
    val <= : Word.bitSequence -> Word.bitSequence -> bool
    val > : Word.bitSequence -> Word.bitSequence -> bool
    val >= : Word.bitSequence -> Word.bitSequence -> bool
    val compare : 
                    Word.bitSequence -> Word.bitSequence -> Basic_classes.ordering

  end

  module Instance_Basic_classes_SetType_Word_bitSequence = struct

    val setElemCompare : 
                           Word.bitSequence -> Word.bitSequence -> Basic_classes.ordering

  end

  module Instance_Num_NumAdd_Word_bitSequence = struct

    val + : Word.bitSequence -> Word.bitSequence -> Word.bitSequence

  end

  module Instance_Num_NumDivision_Word_bitSequence = struct

    val / : Word.bitSequence -> Word.bitSequence -> Word.bitSequence

  end

  module Instance_Num_NumIntegerDivision_Word_bitSequence = struct

    val div : Word.bitSequence -> Word.bitSequence -> Word.bitSequence

  end

  module Instance_Num_NumMinus_Word_bitSequence = struct

    val - : Word.bitSequence -> Word.bitSequence -> Word.bitSequence

  end

  module Instance_Num_NumMult_Word_bitSequence = struct

    val * : Word.bitSequence -> Word.bitSequence -> Word.bitSequence

  end

  module Instance_Num_NumNegate_Word_bitSequence = struct

    val ~ : Word.bitSequence -> Word.bitSequence

  end

  module Instance_Num_NumPow_Word_bitSequence = struct

    val ** : Word.bitSequence -> nat -> Word.bitSequence

  end

  module Instance_Num_NumPred_Word_bitSequence = struct

    val pred : Word.bitSequence -> Word.bitSequence

  end

  module Instance_Num_NumRemainder_Word_bitSequence = struct

    val mod : Word.bitSequence -> Word.bitSequence -> Word.bitSequence

  end

  module Instance_Num_NumSucc_Word_bitSequence = struct

    val succ : Word.bitSequence -> Word.bitSequence

  end

  module Instance_Num_Numeral_Word_bitSequence = struct

    val fromNumeral : numeral -> Word.bitSequence

  end

  module Instance_Word_WordAnd_Num_int = struct

    val land : Num.int -> Num.int -> Num.int

  end

  module Instance_Word_WordAnd_Num_int32 = struct

    val land : Num.int32 -> Num.int32 -> Num.int32

  end

  module Instance_Word_WordAnd_Num_int64 = struct

    val land : Num.int64 -> Num.int64 -> Num.int64

  end

  module Instance_Word_WordAnd_Num_integer = struct

    val land : Num.integer -> Num.integer -> Num.integer

  end

  module Instance_Word_WordAnd_Num_natural = struct

    val land : Num.natural -> Num.natural -> Num.natural

  end

  module Instance_Word_WordAnd_Word_bitSequence = struct

    val land : Word.bitSequence -> Word.bitSequence -> Word.bitSequence

  end

  module Instance_Word_WordAnd_nat = struct

    val land : nat -> nat -> nat

  end

  module Instance_Word_WordAsr_Num_int = struct

    val asr : Num.int -> nat -> Num.int

  end

  module Instance_Word_WordAsr_Num_int32 = struct

    val asr : Num.int32 -> nat -> Num.int32

  end

  module Instance_Word_WordAsr_Num_int64 = struct

    val asr : Num.int64 -> nat -> Num.int64

  end

  module Instance_Word_WordAsr_Num_integer = struct

    val asr : Num.integer -> nat -> Num.integer

  end

  module Instance_Word_WordAsr_Num_natural = struct

    val asr : Num.natural -> nat -> Num.natural

  end

  module Instance_Word_WordAsr_Word_bitSequence = struct

    val asr : Word.bitSequence -> nat -> Word.bitSequence

  end

  module Instance_Word_WordAsr_nat = struct

    val asr : nat -> nat -> nat

  end

  module Instance_Word_WordLsl_Num_int = struct

    val lsl : Num.int -> nat -> Num.int

  end

  module Instance_Word_WordLsl_Num_int32 = struct

    val lsl : Num.int32 -> nat -> Num.int32

  end

  module Instance_Word_WordLsl_Num_int64 = struct

    val lsl : Num.int64 -> nat -> Num.int64

  end

  module Instance_Word_WordLsl_Num_integer = struct

    val lsl : Num.integer -> nat -> Num.integer

  end

  module Instance_Word_WordLsl_Num_natural = struct

    val lsl : Num.natural -> nat -> Num.natural

  end

  module Instance_Word_WordLsl_Word_bitSequence = struct

    val lsl : Word.bitSequence -> nat -> Word.bitSequence

  end

  module Instance_Word_WordLsl_nat = struct

    val lsl : nat -> nat -> nat

  end

  module Instance_Word_WordLsr_Num_int32 = struct

    val lsr : Num.int32 -> nat -> Num.int32

  end

  module Instance_Word_WordLsr_Num_int64 = struct

    val lsr : Num.int64 -> nat -> Num.int64

  end

  module Instance_Word_WordLsr_Num_integer = struct

    val lsr : Num.integer -> nat -> Num.integer

  end

  module Instance_Word_WordLsr_Num_natural = struct

    val lsr : Num.natural -> nat -> Num.natural

  end

  module Instance_Word_WordLsr_Word_bitSequence = struct

    val lsr : Word.bitSequence -> nat -> Word.bitSequence

  end

  module Instance_Word_WordNot_Num_int = struct

    val lnot : Num.int -> Num.int

  end

  module Instance_Word_WordNot_Num_int32 = struct

    val lnot : Num.int32 -> Num.int32

  end

  module Instance_Word_WordNot_Num_int64 = struct

    val lnot : Num.int64 -> Num.int64

  end

  module Instance_Word_WordNot_Num_integer = struct

    val lnot : Num.integer -> Num.integer

  end

  module Instance_Word_WordNot_Word_bitSequence = struct

    val lnot : Word.bitSequence -> Word.bitSequence

  end

  module Instance_Word_WordOr_Num_int = struct

    val lor : Num.int -> Num.int -> Num.int

  end

  module Instance_Word_WordOr_Num_int32 = struct

    val lor : Num.int32 -> Num.int32 -> Num.int32

  end

  module Instance_Word_WordOr_Num_int64 = struct

    val lor : Num.int64 -> Num.int64 -> Num.int64

  end

  module Instance_Word_WordOr_Num_integer = struct

    val lor : Num.integer -> Num.integer -> Num.integer

  end

  module Instance_Word_WordOr_Num_natural = struct

    val lor : Num.natural -> Num.natural -> Num.natural

  end

  module Instance_Word_WordOr_Word_bitSequence = struct

    val lor : Word.bitSequence -> Word.bitSequence -> Word.bitSequence

  end

  module Instance_Word_WordOr_nat = struct

    val lor : nat -> nat -> nat

  end

  module Instance_Word_WordXor_Num_int = struct

    val lxor : Num.int -> Num.int -> Num.int

  end

  module Instance_Word_WordXor_Num_int32 = struct

    val lxor : Num.int32 -> Num.int32 -> Num.int32

  end

  module Instance_Word_WordXor_Num_int64 = struct

    val lxor : Num.int64 -> Num.int64 -> Num.int64

  end

  module Instance_Word_WordXor_Num_integer = struct

    val lxor : Num.integer -> Num.integer -> Num.integer

  end

  module Instance_Word_WordXor_Num_natural = struct

    val lxor : Num.natural -> Num.natural -> Num.natural

  end

  module Instance_Word_WordXor_Word_bitSequence = struct

    val lxor : Word.bitSequence -> Word.bitSequence -> Word.bitSequence

  end

  module Instance_Word_WordXor_nat = struct

    val lxor : nat -> nat -> nat

  end

end

